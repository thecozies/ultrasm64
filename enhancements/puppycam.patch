diff --git a/Makefile b/Makefile
index 0587363..a8d5c82 100644
--- a/Makefile
+++ b/Makefile
@@ -249,7 +249,7 @@ else
 ifeq ($(VERSION),sh)
   OPT_FLAGS := -O2
 else
-  OPT_FLAGS := -g
+  OPT_FLAGS := -O2
 endif
 endif
 
@@ -607,6 +607,8 @@ $(BUILD_DIR)/include/text_strings.h: $(BUILD_DIR)/include/text_menu_strings.h
 $(BUILD_DIR)/src/menu/file_select.o: $(BUILD_DIR)/include/text_strings.h
 $(BUILD_DIR)/src/menu/star_select.o: $(BUILD_DIR)/include/text_strings.h
 $(BUILD_DIR)/src/game/ingame_menu.o: $(BUILD_DIR)/include/text_strings.h
+$(BUILD_DIR)/src/game/camera.o: $(BUILD_DIR)/include/text_strings.h
+
 
 ################################################################
 # TEXTURE GENERATION                                           #
diff --git a/Makefile.orig b/Makefile.orig
new file mode 100644
index 0000000..0587363
--- /dev/null
+++ b/Makefile.orig
@@ -0,0 +1,836 @@
+# Makefile to rebuild SM64 split image
+
+### Default target ###
+
+default: all
+
+### Build Options ###
+
+# These options can either be changed by modifying the makefile, or
+# by building with 'make SETTING=value'. 'make clean' may be required.
+
+# Version of the game to build
+VERSION ?= us
+# Graphics microcode used
+GRUCODE ?= f3d_old
+# If COMPARE is 1, check the output sha1sum when building 'all'
+COMPARE ?= 1
+# If NON_MATCHING is 1, define the NON_MATCHING and AVOID_UB macros when building (recommended)
+NON_MATCHING ?= 0
+# Build for the N64 (turn this off for ports)
+TARGET_N64 ?= 0
+# Build for Emscripten/WebGL
+TARGET_WEB ?= 0
+# Compiler to use (ido or gcc)
+COMPILER ?= ido
+
+# Automatic settings only for ports
+ifeq ($(TARGET_N64),0)
+
+  NON_MATCHING := 1
+  GRUCODE := f3dex2e
+  TARGET_WINDOWS := 0
+  ifeq ($(TARGET_WEB),0)
+    ifeq ($(OS),Windows_NT)
+      TARGET_WINDOWS := 1
+    else
+      # TODO: Detect Mac OS X, BSD, etc. For now, assume Linux
+      TARGET_LINUX := 1
+    endif
+  endif
+
+  ifeq ($(TARGET_WINDOWS),1)
+    # On Windows, default to DirectX 11
+    ifneq ($(ENABLE_OPENGL),1)
+      ifneq ($(ENABLE_DX12),1)
+        ENABLE_DX11 ?= 1
+      endif
+    endif
+  else
+    # On others, default to OpenGL
+    ENABLE_OPENGL ?= 1
+  endif
+
+  # Sanity checks
+  ifeq ($(ENABLE_DX11),1)
+    ifneq ($(TARGET_WINDOWS),1)
+      $(error The DirectX 11 backend is only supported on Windows)
+    endif
+    ifeq ($(ENABLE_OPENGL),1)
+      $(error Cannot specify multiple graphics backends)
+    endif
+    ifeq ($(ENABLE_DX12),1)
+      $(error Cannot specify multiple graphics backends)
+    endif
+  endif
+  ifeq ($(ENABLE_DX12),1)
+    ifneq ($(TARGET_WINDOWS),1)
+      $(error The DirectX 12 backend is only supported on Windows)
+    endif
+    ifeq ($(ENABLE_OPENGL),1)
+      $(error Cannot specify multiple graphics backends)
+    endif
+    ifeq ($(ENABLE_DX11),1)
+      $(error Cannot specify multiple graphics backends)
+    endif
+  endif
+
+endif
+
+ifeq ($(COMPILER),gcc)
+  NON_MATCHING := 1
+endif
+
+# Release
+
+ifeq ($(VERSION),jp)
+  VERSION_DEF := VERSION_JP
+  GRUCODE_DEF := F3D_OLD
+else
+ifeq ($(VERSION),us)
+  VERSION_DEF := VERSION_US
+  GRUCODE_DEF := F3D_OLD
+else
+ifeq ($(VERSION),eu)
+  VERSION_DEF := VERSION_EU
+  GRUCODE_DEF := F3D_NEW
+else
+ifeq ($(VERSION),sh)
+  $(warning Building SH is experimental and is prone to breaking. Try at your own risk.)
+  VERSION_DEF := VERSION_SH
+  GRUCODE_DEF := F3D_NEW
+# TODO: GET RID OF THIS!!! We should mandate assets for Shindou like EU but we dont have the addresses extracted yet so we'll just pretend you have everything extracted for now.
+  NOEXTRACT := 1 
+else
+  $(error unknown version "$(VERSION)")
+endif
+endif
+endif
+endif
+
+TARGET := sm64.$(VERSION)
+VERSION_CFLAGS := -D$(VERSION_DEF)
+VERSION_ASFLAGS := --defsym $(VERSION_DEF)=1
+
+# Microcode
+
+ifeq ($(GRUCODE),f3dex) # Fast3DEX
+  GRUCODE_DEF := F3DEX_GBI
+  GRUCODE_ASFLAGS := --defsym F3DEX_GBI_SHARED=1
+  TARGET := $(TARGET).f3dex
+  COMPARE := 0
+else
+ifeq ($(GRUCODE), f3dex2) # Fast3DEX2
+  GRUCODE_DEF := F3DEX_GBI_2
+  GRUCODE_ASFLAGS := --defsym F3DEX_GBI_SHARED=1
+  TARGET := $(TARGET).f3dex2
+  COMPARE := 0
+else
+ifeq ($(GRUCODE), f3dex2e) # Fast3DEX2 Extended (for PC)
+  GRUCODE_DEF := F3DEX_GBI_2E
+  TARGET := $(TARGET).f3dex2e
+  COMPARE := 0
+else
+ifeq ($(GRUCODE),f3d_new) # Fast3D 2.0H (Shindou)
+  GRUCODE_DEF := F3D_NEW
+  TARGET := $(TARGET).f3d_new
+  COMPARE := 0
+else
+ifeq ($(GRUCODE),f3dzex) # Fast3DZEX (2.0J / Animal Forest - DÅbutsu no Mori)
+  $(warning Fast3DZEX is experimental. Try at your own risk.)
+  GRUCODE_DEF := F3DEX_GBI_2
+  GRUCODE_ASFLAGS := --defsym F3DEX_GBI_SHARED=1
+  TARGET := $(TARGET).f3dzex
+  COMPARE := 0
+endif
+endif
+endif
+endif
+endif
+
+GRUCODE_CFLAGS := -D$(GRUCODE_DEF)
+GRUCODE_ASFLAGS := $(GRUCODE_ASFLAGS) --defsym $(GRUCODE_DEF)=1
+
+ifeq ($(NON_MATCHING),1)
+  MATCH_CFLAGS := -DNON_MATCHING -DAVOID_UB
+  MATCH_ASFLAGS := --defsym AVOID_UB=1
+  COMPARE := 0
+endif
+
+################### Universal Dependencies ###################
+
+# (This is a bit hacky, but a lot of rules implicitly depend
+# on tools and assets, and we use directory globs further down
+# in the makefile that we want should cover assets.)
+
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(MAKECMDGOALS),distclean)
+
+# Make sure assets exist
+NOEXTRACT ?= 0
+ifeq ($(NOEXTRACT),0)
+DUMMY != ./extract_assets.py $(VERSION) >&2 || echo FAIL
+ifeq ($(DUMMY),FAIL)
+  $(error Failed to extract assets)
+endif
+endif
+
+# Make tools if out of date
+DUMMY != make -s -C tools >&2 || echo FAIL
+ifeq ($(DUMMY),FAIL)
+  $(error Failed to build tools)
+endif
+
+endif
+endif
+
+################ Target Executable and Sources ###############
+
+# BUILD_DIR is location where all build artifacts are placed
+BUILD_DIR_BASE := build
+ifeq ($(TARGET_N64),1)
+  BUILD_DIR := $(BUILD_DIR_BASE)/$(VERSION)
+else
+ifeq ($(TARGET_WEB),1)
+  BUILD_DIR := $(BUILD_DIR_BASE)/$(VERSION)_web
+else
+  BUILD_DIR := $(BUILD_DIR_BASE)/$(VERSION)_pc
+endif
+endif
+
+LIBULTRA := $(BUILD_DIR)/libultra.a
+ifeq ($(TARGET_WEB),1)
+EXE := $(BUILD_DIR)/$(TARGET).html
+else
+ifeq ($(TARGET_WINDOWS),1)
+EXE := $(BUILD_DIR)/$(TARGET).exe
+else
+EXE := $(BUILD_DIR)/$(TARGET)
+endif
+endif
+ROM := $(BUILD_DIR)/$(TARGET).z64
+ELF := $(BUILD_DIR)/$(TARGET).elf
+LD_SCRIPT := sm64.ld
+MIO0_DIR := $(BUILD_DIR)/bin
+SOUND_BIN_DIR := $(BUILD_DIR)/sound
+TEXTURE_DIR := textures
+ACTOR_DIR := actors
+LEVEL_DIRS := $(patsubst levels/%,%,$(dir $(wildcard levels/*/header.h)))
+
+# Directories containing source files
+SRC_DIRS := src src/engine src/game src/audio src/menu src/buffers actors levels bin bin/$(VERSION) data assets
+ASM_DIRS := lib
+ifeq ($(TARGET_N64),1)
+  ASM_DIRS := asm $(ASM_DIRS)
+else
+  SRC_DIRS := $(SRC_DIRS) src/pc src/pc/gfx src/pc/audio src/pc/controller
+  ASM_DIRS :=
+endif
+BIN_DIRS := bin bin/$(VERSION)
+
+ULTRA_SRC_DIRS := lib/src lib/src/math
+ULTRA_ASM_DIRS := lib/asm lib/data
+ULTRA_BIN_DIRS := lib/bin
+
+GODDARD_SRC_DIRS := src/goddard src/goddard/dynlists
+
+MIPSISET := -mips2
+MIPSBIT := -32
+
+ifeq ($(COMPILER),gcc)
+  MIPSISET := -mips3
+endif
+
+ifeq ($(TARGET_N64),1)
+
+ifeq ($(VERSION),eu)
+  OPT_FLAGS := -O2
+else
+ifeq ($(VERSION),sh)
+  OPT_FLAGS := -O2
+else
+  OPT_FLAGS := -g
+endif
+endif
+
+  # Use a default opt flag for gcc
+  ifeq ($(COMPILER),gcc)
+    OPT_FLAGS := -O2
+  endif
+
+else
+ifeq ($(TARGET_WEB),1)
+  OPT_FLAGS := -O2 -g4 --source-map-base http://localhost:8080/
+else
+  OPT_FLAGS := -O2
+endif
+endif
+
+# File dependencies and variables for specific files
+include Makefile.split
+
+# Source code files
+LEVEL_C_FILES := $(wildcard levels/*/leveldata.c) $(wildcard levels/*/script.c) $(wildcard levels/*/geo.c)
+C_FILES := $(foreach dir,$(SRC_DIRS),$(wildcard $(dir)/*.c)) $(LEVEL_C_FILES)
+CXX_FILES := $(foreach dir,$(SRC_DIRS),$(wildcard $(dir)/*.cpp))
+S_FILES := $(foreach dir,$(ASM_DIRS),$(wildcard $(dir)/*.s))
+ULTRA_C_FILES := $(foreach dir,$(ULTRA_SRC_DIRS),$(wildcard $(dir)/*.c))
+GODDARD_C_FILES := $(foreach dir,$(GODDARD_SRC_DIRS),$(wildcard $(dir)/*.c))
+ifeq ($(TARGET_N64),1)
+  ULTRA_S_FILES := $(foreach dir,$(ULTRA_ASM_DIRS),$(wildcard $(dir)/*.s))
+endif
+GENERATED_C_FILES := $(BUILD_DIR)/assets/mario_anim_data.c $(BUILD_DIR)/assets/demo_data.c \
+  $(addprefix $(BUILD_DIR)/bin/,$(addsuffix _skybox.c,$(notdir $(basename $(wildcard textures/skyboxes/*.png)))))
+
+ifeq ($(TARGET_WINDOWS),0)
+  CXX_FILES :=
+endif
+
+ifneq ($(TARGET_N64),1)
+  ULTRA_C_FILES := \
+    alBnkfNew.c \
+    guLookAtRef.c \
+    guMtxF2L.c \
+    guNormalize.c \
+    guOrthoF.c \
+    guPerspectiveF.c \
+    guRotateF.c \
+    guScaleF.c \
+    guTranslateF.c
+
+  C_FILES := $(filter-out src/game/main.c,$(C_FILES))
+  ULTRA_C_FILES := $(addprefix lib/src/,$(ULTRA_C_FILES))
+endif
+
+ifeq ($(VERSION),sh)
+SOUND_BANK_FILES := $(wildcard sound/sound_banks/*.json)
+SOUND_SEQUENCE_FILES := $(wildcard sound/sequences/jp/*.m64) \
+    $(wildcard sound/sequences/*.m64) \
+    $(foreach file,$(wildcard sound/sequences/jp/*.s),$(BUILD_DIR)/$(file:.s=.m64)) \
+    $(foreach file,$(wildcard sound/sequences/*.s),$(BUILD_DIR)/$(file:.s=.m64))
+else
+SOUND_BANK_FILES := $(wildcard sound/sound_banks/*.json)
+SOUND_SEQUENCE_FILES := $(wildcard sound/sequences/$(VERSION)/*.m64) \
+    $(wildcard sound/sequences/*.m64) \
+    $(foreach file,$(wildcard sound/sequences/$(VERSION)/*.s),$(BUILD_DIR)/$(file:.s=.m64)) \
+    $(foreach file,$(wildcard sound/sequences/*.s),$(BUILD_DIR)/$(file:.s=.m64))
+endif
+
+SOUND_SAMPLE_DIRS := $(wildcard sound/samples/*)
+SOUND_SAMPLE_AIFFS := $(foreach dir,$(SOUND_SAMPLE_DIRS),$(wildcard $(dir)/*.aiff))
+SOUND_SAMPLE_TABLES := $(foreach file,$(SOUND_SAMPLE_AIFFS),$(BUILD_DIR)/$(file:.aiff=.table))
+SOUND_SAMPLE_AIFCS := $(foreach file,$(SOUND_SAMPLE_AIFFS),$(BUILD_DIR)/$(file:.aiff=.aifc))
+SOUND_OBJ_FILES := $(SOUND_BIN_DIR)/sound_data.o
+
+
+# Object files
+O_FILES := $(foreach file,$(C_FILES),$(BUILD_DIR)/$(file:.c=.o)) \
+           $(foreach file,$(CXX_FILES),$(BUILD_DIR)/$(file:.cpp=.o)) \
+           $(foreach file,$(S_FILES),$(BUILD_DIR)/$(file:.s=.o)) \
+           $(foreach file,$(GENERATED_C_FILES),$(file:.c=.o))
+
+ULTRA_O_FILES := $(foreach file,$(ULTRA_S_FILES),$(BUILD_DIR)/$(file:.s=.o)) \
+                 $(foreach file,$(ULTRA_C_FILES),$(BUILD_DIR)/$(file:.c=.o))
+
+GODDARD_O_FILES := $(foreach file,$(GODDARD_C_FILES),$(BUILD_DIR)/$(file:.c=.o))
+
+# Automatic dependency files
+DEP_FILES := $(O_FILES:.o=.d) $(ULTRA_O_FILES:.o=.d) $(GODDARD_O_FILES:.o=.d) $(BUILD_DIR)/$(LD_SCRIPT).d
+
+# Files with GLOBAL_ASM blocks
+ifeq ($(NON_MATCHING),0)
+GLOBAL_ASM_C_FILES != grep -rl 'GLOBAL_ASM(' $(wildcard src/**/*.c)
+GLOBAL_ASM_O_FILES = $(foreach file,$(GLOBAL_ASM_C_FILES),$(BUILD_DIR)/$(file:.c=.o))
+GLOBAL_ASM_DEP = $(BUILD_DIR)/src/audio/non_matching_dep
+endif
+
+# Segment elf files
+SEG_FILES := $(SEGMENT_ELF_FILES) $(ACTOR_ELF_FILES) $(LEVEL_ELF_FILES)
+
+##################### Compiler Options #######################
+INCLUDE_CFLAGS := -I include -I $(BUILD_DIR) -I $(BUILD_DIR)/include -I src -I .
+ENDIAN_BITWIDTH := $(BUILD_DIR)/endian-and-bitwidth
+
+ifeq ($(TARGET_N64),1)
+IRIX_ROOT := tools/ido5.3_compiler
+
+ifeq ($(shell type mips-linux-gnu-ld >/dev/null 2>/dev/null; echo $$?), 0)
+  CROSS := mips-linux-gnu-
+else ifeq ($(shell type mips64-linux-gnu-ld >/dev/null 2>/dev/null; echo $$?), 0)
+  CROSS := mips64-linux-gnu-
+else
+  CROSS := mips64-elf-
+endif
+
+# check that either QEMU_IRIX is set or qemu-irix package installed
+ifeq ($(COMPILER),ido)
+  ifndef QEMU_IRIX
+    QEMU_IRIX := $(shell which qemu-irix 2>/dev/null)
+    ifeq (, $(QEMU_IRIX))
+      $(error Please install qemu-irix package or set QEMU_IRIX env var to the full qemu-irix binary path)
+    endif
+  endif
+endif
+
+AS        := $(CROSS)as
+CC        := $(QEMU_IRIX) -silent -L $(IRIX_ROOT) $(IRIX_ROOT)/usr/bin/cc
+CPP       := cpp -P -Wno-trigraphs
+LD        := $(CROSS)ld
+AR        := $(CROSS)ar
+OBJDUMP   := $(CROSS)objdump
+OBJCOPY   := $(CROSS)objcopy
+PYTHON    := python3
+
+# change the compiler to gcc, to use the default, install the gcc-mips-linux-gnu package
+ifeq ($(COMPILER),gcc)
+  CC        := $(CROSS)gcc
+endif
+
+ifeq ($(TARGET_N64),1)
+  TARGET_CFLAGS := -nostdinc -I include/libc -DTARGET_N64 -D_LANGUAGE_C
+  CC_CFLAGS := -fno-builtin
+endif
+
+INCLUDE_CFLAGS := -I include -I $(BUILD_DIR) -I $(BUILD_DIR)/include -I src -I .
+
+# Check code syntax with host compiler
+CC_CHECK := gcc
+CC_CHECK_CFLAGS := -fsyntax-only -fsigned-char $(CC_CFLAGS) $(TARGET_CFLAGS) $(INCLUDE_CFLAGS) -std=gnu90 -Wall -Wextra -Wno-format-security -Wno-main -DNON_MATCHING -DAVOID_UB $(VERSION_CFLAGS) $(GRUCODE_CFLAGS)
+
+COMMON_CFLAGS = $(OPT_FLAGS) $(TARGET_CFLAGS) $(INCLUDE_CFLAGS) $(VERSION_CFLAGS) $(MATCH_CFLAGS) $(MIPSISET) $(GRUCODE_CFLAGS)
+
+ASFLAGS := -march=vr4300 -mabi=32 -I include -I $(BUILD_DIR) $(VERSION_ASFLAGS) $(MATCH_ASFLAGS) $(GRUCODE_ASFLAGS)
+CFLAGS = -Wab,-r4300_mul -non_shared -G 0 -Xcpluscomm -Xfullwarn -signed $(COMMON_CFLAGS) $(MIPSBIT)
+OBJCOPYFLAGS := --pad-to=0x800000 --gap-fill=0xFF
+SYMBOL_LINKING_FLAGS := $(addprefix -R ,$(SEG_FILES))
+LDFLAGS := -T undefined_syms.txt -T $(BUILD_DIR)/$(LD_SCRIPT) -Map $(BUILD_DIR)/sm64.$(VERSION).map --no-check-sections $(SYMBOL_LINKING_FLAGS)
+ENDIAN_BITWIDTH := $(BUILD_DIR)/endian-and-bitwidth
+
+ifeq ($(COMPILER),gcc)
+  CFLAGS := -march=vr4300 -mfix4300 -mabi=32 -mno-shared -G 0 -mhard-float -fno-stack-protector -fno-common -fno-zero-initialized-in-bss -I include -I src/ -I $(BUILD_DIR)/include -fno-PIC -mno-abicalls -fno-strict-aliasing -fno-inline-functions -ffreestanding -fwrapv -Wall -Wextra $(COMMON_CFLAGS)
+endif
+
+ifeq ($(shell getconf LONG_BIT), 32)
+  # Work around memory allocation bug in QEMU
+  export QEMU_GUEST_BASE := 1
+else
+  # Ensure that gcc treats the code as 32-bit
+  CC_CHECK_CFLAGS += -m32
+endif
+
+# Prevent a crash with -sopt
+export LANG := C
+
+else # TARGET_N64
+
+AS := as
+ifneq ($(TARGET_WEB),1)
+  CC := gcc
+  CXX := g++
+else
+  CC := emcc
+endif
+ifeq ($(TARGET_WINDOWS),1)
+  LD := $(CXX)
+else
+  LD := $(CC)
+endif
+CPP := cpp -P
+OBJDUMP := objdump
+OBJCOPY := objcopy
+PYTHON := python3
+
+# Platform-specific compiler and linker flags
+ifeq ($(TARGET_WINDOWS),1)
+  PLATFORM_CFLAGS  := -DTARGET_WINDOWS
+  PLATFORM_LDFLAGS := -lm -lxinput9_1_0 -lole32 -no-pie -mwindows
+endif
+ifeq ($(TARGET_LINUX),1)
+  PLATFORM_CFLAGS  := -DTARGET_LINUX `pkg-config --cflags libusb-1.0`
+  PLATFORM_LDFLAGS := -lm -lpthread `pkg-config --libs libusb-1.0` -lasound -lpulse -no-pie
+endif
+ifeq ($(TARGET_WEB),1)
+  PLATFORM_CFLAGS  := -DTARGET_WEB
+  PLATFORM_LDFLAGS := -lm -no-pie -s TOTAL_MEMORY=20MB -g4 --source-map-base http://localhost:8080/ -s "EXTRA_EXPORTED_RUNTIME_METHODS=['callMain']"
+endif
+
+PLATFORM_CFLAGS += -DNO_SEGMENTED_MEMORY
+
+# Compiler and linker flags for graphics backend
+ifeq ($(ENABLE_OPENGL),1)
+  GFX_CFLAGS  := -DENABLE_OPENGL
+  GFX_LDFLAGS :=
+  ifeq ($(TARGET_WINDOWS),1)
+    GFX_CFLAGS  += $(shell sdl2-config --cflags) -DGLEW_STATIC
+    GFX_LDFLAGS += $(shell sdl2-config --libs) -lglew32 -lopengl32 -lwinmm -limm32 -lversion -loleaut32 -lsetupapi
+  endif
+  ifeq ($(TARGET_LINUX),1)
+    GFX_CFLAGS  += $(shell sdl2-config --cflags)
+    GFX_LDFLAGS += -lGL $(shell sdl2-config --libs) -lX11 -lXrandr
+  endif
+  ifeq ($(TARGET_WEB),1)
+    GFX_CFLAGS  += -s USE_SDL=2
+    GFX_LDFLAGS += -lGL -lSDL2
+  endif
+endif
+ifeq ($(ENABLE_DX11),1)
+  GFX_CFLAGS := -DENABLE_DX11
+  PLATFORM_LDFLAGS += -lgdi32 -static
+endif
+ifeq ($(ENABLE_DX12),1)
+  GFX_CFLAGS := -DENABLE_DX12
+  PLATFORM_LDFLAGS += -lgdi32 -static
+endif
+
+GFX_CFLAGS += -DWIDESCREEN
+
+CC_CHECK := $(CC) -fsyntax-only -fsigned-char $(INCLUDE_CFLAGS) -Wall -Wextra -Wno-format-security -D_LANGUAGE_C $(VERSION_CFLAGS) $(MATCH_CFLAGS) $(PLATFORM_CFLAGS) $(GFX_CFLAGS) $(GRUCODE_CFLAGS)
+CFLAGS := $(OPT_FLAGS) $(INCLUDE_CFLAGS) -D_LANGUAGE_C $(VERSION_CFLAGS) $(MATCH_CFLAGS) $(PLATFORM_CFLAGS) $(GFX_CFLAGS) $(GRUCODE_CFLAGS) -fno-strict-aliasing -fwrapv -march=native
+
+ASFLAGS := -I include -I $(BUILD_DIR) $(VERSION_ASFLAGS)
+
+LDFLAGS := $(PLATFORM_LDFLAGS) $(GFX_LDFLAGS)
+
+endif
+
+####################### Other Tools #########################
+
+# N64 tools
+TOOLS_DIR = tools
+MIO0TOOL = $(TOOLS_DIR)/mio0
+N64CKSUM = $(TOOLS_DIR)/n64cksum
+N64GRAPHICS = $(TOOLS_DIR)/n64graphics
+N64GRAPHICS_CI = $(TOOLS_DIR)/n64graphics_ci
+TEXTCONV = $(TOOLS_DIR)/textconv
+AIFF_EXTRACT_CODEBOOK = $(TOOLS_DIR)/aiff_extract_codebook
+VADPCM_ENC = $(TOOLS_DIR)/vadpcm_enc
+EXTRACT_DATA_FOR_MIO = $(TOOLS_DIR)/extract_data_for_mio
+SKYCONV = $(TOOLS_DIR)/skyconv
+EMULATOR = mupen64plus
+EMU_FLAGS = --noosd
+LOADER = loader64
+LOADER_FLAGS = -vwf
+SHA1SUM = sha1sum
+
+ifeq (, $(shell which armips 2>/dev/null))
+  RSPASM := $(TOOLS_DIR)/armips
+else
+  RSPASM = armips
+endif
+
+# Use Objcopy instead of extract_data_for_mio
+ifeq ($(COMPILER),gcc)
+EXTRACT_DATA_FOR_MIO := $(OBJCOPY) -O binary --only-section=.data
+endif
+
+######################## Targets #############################
+
+ifeq ($(TARGET_N64),1)
+all: $(ROM)
+ifeq ($(COMPARE),1)
+	@$(SHA1SUM) -c $(TARGET).sha1 || (echo 'The build succeeded, but did not match the official ROM. This is expected if you are making changes to the game.\nTo silence this message, use "make COMPARE=0"'. && false)
+endif
+else
+all: $(EXE)
+endif
+
+clean:
+	$(RM) -r $(BUILD_DIR_BASE)
+
+distclean:
+	$(RM) -r $(BUILD_DIR_BASE)
+	./extract_assets.py --clean
+
+test: $(ROM)
+	$(EMULATOR) $(EMU_FLAGS) $<
+
+load: $(ROM)
+	$(LOADER) $(LOADER_FLAGS) $<
+
+libultra: $(BUILD_DIR)/libultra.a
+
+$(BUILD_DIR)/asm/boot.o: $(IPL3_RAW_FILES)
+$(BUILD_DIR)/src/game/crash_screen.o: $(CRASH_TEXTURE_C_FILES)
+
+$(BUILD_DIR)/lib/rsp.o: $(BUILD_DIR)/rsp/rspboot.bin $(BUILD_DIR)/rsp/fast3d.bin $(BUILD_DIR)/rsp/audio.bin
+
+$(BUILD_DIR)/include/text_strings.h: include/text_strings.h.in
+	$(TEXTCONV) charmap.txt $< $@
+
+$(BUILD_DIR)/include/text_menu_strings.h: include/text_menu_strings.h.in
+	$(TEXTCONV) charmap_menu.txt $< $@
+
+ifeq ($(COMPILER),gcc)
+$(BUILD_DIR)/lib/src/math/%.o: CFLAGS += -fno-builtin
+endif
+
+ifeq ($(VERSION),eu)
+TEXT_DIRS := text/de text/us text/fr
+
+# EU encoded text inserted into individual segment 0x19 files,
+# and course data also duplicated in leveldata.c
+$(BUILD_DIR)/bin/eu/translation_en.o: $(BUILD_DIR)/text/us/define_text.inc.c
+$(BUILD_DIR)/bin/eu/translation_de.o: $(BUILD_DIR)/text/de/define_text.inc.c
+$(BUILD_DIR)/bin/eu/translation_fr.o: $(BUILD_DIR)/text/fr/define_text.inc.c
+$(BUILD_DIR)/levels/menu/leveldata.o: $(BUILD_DIR)/text/us/define_courses.inc.c
+$(BUILD_DIR)/levels/menu/leveldata.o: $(BUILD_DIR)/text/de/define_courses.inc.c
+$(BUILD_DIR)/levels/menu/leveldata.o: $(BUILD_DIR)/text/fr/define_courses.inc.c
+
+else
+ifeq ($(VERSION),sh)
+TEXT_DIRS := text/jp
+$(BUILD_DIR)/bin/segment2.o: $(BUILD_DIR)/text/jp/define_text.inc.c
+
+else
+TEXT_DIRS := text/$(VERSION)
+
+# non-EU encoded text inserted into segment 0x02
+$(BUILD_DIR)/bin/segment2.o: $(BUILD_DIR)/text/$(VERSION)/define_text.inc.c
+endif
+endif
+
+$(BUILD_DIR)/text/%/define_courses.inc.c: text/define_courses.inc.c text/%/courses.h
+	$(CPP) $(VERSION_CFLAGS) $< -o $@ -I text/$*/
+	$(TEXTCONV) charmap.txt $@ $@
+
+$(BUILD_DIR)/text/%/define_text.inc.c: text/define_text.inc.c text/%/courses.h text/%/dialogs.h
+	$(CPP) $(VERSION_CFLAGS) $< -o $@ -I text/$*/
+	$(TEXTCONV) charmap.txt $@ $@
+
+RSP_DIRS := $(BUILD_DIR)/rsp
+ALL_DIRS := $(BUILD_DIR) $(addprefix $(BUILD_DIR)/,$(SRC_DIRS) $(ASM_DIRS) $(GODDARD_SRC_DIRS) $(ULTRA_SRC_DIRS) $(ULTRA_ASM_DIRS) $(ULTRA_BIN_DIRS) $(BIN_DIRS) $(TEXTURE_DIRS) $(TEXT_DIRS) $(SOUND_SAMPLE_DIRS) $(addprefix levels/,$(LEVEL_DIRS)) include) $(MIO0_DIR) $(addprefix $(MIO0_DIR)/,$(VERSION)) $(SOUND_BIN_DIR) $(SOUND_BIN_DIR)/sequences/$(VERSION) $(RSP_DIRS)
+
+# Make sure build directory exists before compiling anything
+DUMMY != mkdir -p $(ALL_DIRS)
+
+$(BUILD_DIR)/include/text_strings.h: $(BUILD_DIR)/include/text_menu_strings.h
+$(BUILD_DIR)/src/menu/file_select.o: $(BUILD_DIR)/include/text_strings.h
+$(BUILD_DIR)/src/menu/star_select.o: $(BUILD_DIR)/include/text_strings.h
+$(BUILD_DIR)/src/game/ingame_menu.o: $(BUILD_DIR)/include/text_strings.h
+
+################################################################
+# TEXTURE GENERATION                                           #
+################################################################
+
+# RGBA32, RGBA16, IA16, IA8, IA4, IA1, I8, I4
+$(BUILD_DIR)/%: %.png
+	$(N64GRAPHICS) -i $@ -g $< -f $(lastword $(subst ., ,$@))
+
+$(BUILD_DIR)/%.inc.c: $(BUILD_DIR)/% %.png
+	hexdump -v -e '1/1 "0x%X,"' $< > $@
+	echo >> $@
+
+# Color Index CI8
+$(BUILD_DIR)/%.ci8: %.ci8.png
+	$(N64GRAPHICS_CI) -i $@ -g $< -f ci8
+
+# Color Index CI4
+$(BUILD_DIR)/%.ci4: %.ci4.png
+	$(N64GRAPHICS_CI) -i $@ -g $< -f ci4
+
+################################################################
+
+# compressed segment generation
+
+ifeq ($(TARGET_N64),1)
+# TODO: ideally this would be `-Trodata-segment=0x07000000` but that doesn't set the address
+
+$(BUILD_DIR)/bin/%.elf: $(BUILD_DIR)/bin/%.o
+	$(LD) -e 0 -Ttext=$(SEGMENT_ADDRESS) -Map $@.map -o $@ $<
+$(BUILD_DIR)/actors/%.elf: $(BUILD_DIR)/actors/%.o
+	$(LD) -e 0 -Ttext=$(SEGMENT_ADDRESS) -Map $@.map -o $@ $<
+
+# Override for level.elf, which otherwise matches the above pattern
+.SECONDEXPANSION:
+$(BUILD_DIR)/levels/%/leveldata.elf: $(BUILD_DIR)/levels/%/leveldata.o $(BUILD_DIR)/bin/$$(TEXTURE_BIN).elf
+	$(LD) -e 0 -Ttext=$(SEGMENT_ADDRESS) -Map $@.map --just-symbols=$(BUILD_DIR)/bin/$(TEXTURE_BIN).elf -o $@ $<
+
+$(BUILD_DIR)/bin/%.bin: $(BUILD_DIR)/bin/%.elf
+	$(EXTRACT_DATA_FOR_MIO) $< $@
+
+$(BUILD_DIR)/actors/%.bin: $(BUILD_DIR)/actors/%.elf
+	$(EXTRACT_DATA_FOR_MIO) $< $@
+
+$(BUILD_DIR)/levels/%/leveldata.bin: $(BUILD_DIR)/levels/%/leveldata.elf
+	$(EXTRACT_DATA_FOR_MIO) $< $@
+
+$(BUILD_DIR)/%.mio0: $(BUILD_DIR)/%.bin
+	$(MIO0TOOL) $< $@
+
+$(BUILD_DIR)/%.mio0.o: $(BUILD_DIR)/%.mio0.s
+	$(AS) $(ASFLAGS) -o $@ $<
+
+$(BUILD_DIR)/%.mio0.s: $(BUILD_DIR)/%.mio0
+	printf ".section .data\n\n.incbin \"$<\"\n" > $@
+endif
+
+$(BUILD_DIR)/%.table: %.aiff
+	$(AIFF_EXTRACT_CODEBOOK) $< >$@
+
+$(BUILD_DIR)/%.aifc: $(BUILD_DIR)/%.table %.aiff
+	$(VADPCM_ENC) -c $^ $@
+
+$(BUILD_DIR)/rsp/%.bin $(BUILD_DIR)/rsp/%_data.bin: rsp/%.s
+	$(RSPASM) -sym $@.sym -definelabel $(VERSION_DEF) 1 -definelabel $(GRUCODE_DEF) 1 -strequ CODE_FILE $(BUILD_DIR)/rsp/$*.bin -strequ DATA_FILE $(BUILD_DIR)/rsp/$*_data.bin $<
+
+$(ENDIAN_BITWIDTH): tools/determine-endian-bitwidth.c
+	$(CC) -c $(CFLAGS) -o $@.dummy2 $< 2>$@.dummy1; true
+	grep -o 'msgbegin --endian .* --bitwidth .* msgend' $@.dummy1 > $@.dummy2
+	head -n1 <$@.dummy2 | cut -d' ' -f2-5 > $@
+	@rm $@.dummy1
+	@rm $@.dummy2
+
+$(SOUND_BIN_DIR)/sound_data.ctl: sound/sound_banks/ $(SOUND_BANK_FILES) $(SOUND_SAMPLE_AIFCS) $(ENDIAN_BITWIDTH)
+	$(PYTHON) tools/assemble_sound.py $(BUILD_DIR)/sound/samples/ sound/sound_banks/ $(SOUND_BIN_DIR)/sound_data.ctl $(SOUND_BIN_DIR)/sound_data.tbl $(VERSION_CFLAGS) $$(cat $(ENDIAN_BITWIDTH))
+
+$(SOUND_BIN_DIR)/sound_data.tbl: $(SOUND_BIN_DIR)/sound_data.ctl
+	@true
+
+ifeq ($(VERSION),sh)
+$(SOUND_BIN_DIR)/sequences.bin: $(SOUND_BANK_FILES) sound/sequences.json sound/sequences/ sound/sequences/jp/ $(SOUND_SEQUENCE_FILES) $(ENDIAN_BITWIDTH)
+	$(PYTHON) tools/assemble_sound.py --sequences $@ $(SOUND_BIN_DIR)/bank_sets sound/sound_banks/ sound/sequences.json $(SOUND_SEQUENCE_FILES) $(VERSION_CFLAGS) $$(cat $(ENDIAN_BITWIDTH))
+else
+$(SOUND_BIN_DIR)/sequences.bin: $(SOUND_BANK_FILES) sound/sequences.json sound/sequences/ sound/sequences/$(VERSION)/ $(SOUND_SEQUENCE_FILES) $(ENDIAN_BITWIDTH)
+	$(PYTHON) tools/assemble_sound.py --sequences $@ $(SOUND_BIN_DIR)/bank_sets sound/sound_banks/ sound/sequences.json $(SOUND_SEQUENCE_FILES) $(VERSION_CFLAGS) $$(cat $(ENDIAN_BITWIDTH))
+endif
+
+$(SOUND_BIN_DIR)/bank_sets: $(SOUND_BIN_DIR)/sequences.bin
+	@true
+
+$(SOUND_BIN_DIR)/%.m64: $(SOUND_BIN_DIR)/%.o
+	$(OBJCOPY) -j .rodata $< -O binary $@
+
+$(SOUND_BIN_DIR)/%.o: $(SOUND_BIN_DIR)/%.s
+	$(AS) $(ASFLAGS) -o $@ $<
+
+$(SOUND_BIN_DIR)/%.inc.c: $(SOUND_BIN_DIR)/%
+	hexdump -v -e '1/1 "0x%X,"' $< > $@
+	echo >> $@
+
+$(SOUND_BIN_DIR)/sound_data.o: $(SOUND_BIN_DIR)/sound_data.ctl.inc.c $(SOUND_BIN_DIR)/sound_data.tbl.inc.c $(SOUND_BIN_DIR)/sequences.bin.inc.c $(SOUND_BIN_DIR)/bank_sets.inc.c
+
+$(BUILD_DIR)/levels/scripts.o: $(BUILD_DIR)/include/level_headers.h
+
+$(BUILD_DIR)/include/level_headers.h: levels/level_headers.h.in
+	$(CPP) -I . levels/level_headers.h.in | $(PYTHON) tools/output_level_headers.py > $(BUILD_DIR)/include/level_headers.h
+
+$(BUILD_DIR)/assets/mario_anim_data.c: $(wildcard assets/anims/*.inc.c)
+	$(PYTHON) tools/mario_anims_converter.py > $@
+
+$(BUILD_DIR)/assets/demo_data.c: assets/demo_data.json $(wildcard assets/demos/*.bin)
+	$(PYTHON) tools/demo_data_converter.py assets/demo_data.json $(VERSION_CFLAGS) > $@
+
+ifeq ($(COMPILER),ido)
+# Source code
+$(BUILD_DIR)/levels/%/leveldata.o: OPT_FLAGS := -g
+$(BUILD_DIR)/actors/%.o: OPT_FLAGS := -g
+$(BUILD_DIR)/bin/%.o: OPT_FLAGS := -g
+$(BUILD_DIR)/src/goddard/%.o: OPT_FLAGS := -g
+$(BUILD_DIR)/src/goddard/%.o: MIPSISET := -mips1
+$(BUILD_DIR)/src/audio/%.o: OPT_FLAGS := -O2 -Wo,-loopunroll,0
+$(BUILD_DIR)/src/audio/load.o: OPT_FLAGS := -O2 -framepointer -Wo,-loopunroll,0
+$(BUILD_DIR)/lib/src/%.o: OPT_FLAGS :=
+$(BUILD_DIR)/lib/src/math/ll%.o: MIPSISET := -mips3 -32
+$(BUILD_DIR)/lib/src/math/%.o: OPT_FLAGS := -O2
+$(BUILD_DIR)/lib/src/math/ll%.o: OPT_FLAGS :=
+$(BUILD_DIR)/lib/src/ldiv.o: OPT_FLAGS := -O2
+$(BUILD_DIR)/lib/src/string.o: OPT_FLAGS := -O2
+$(BUILD_DIR)/lib/src/gu%.o: OPT_FLAGS := -O3
+$(BUILD_DIR)/lib/src/al%.o: OPT_FLAGS := -O3
+
+ifeq ($(VERSION),eu)
+$(BUILD_DIR)/lib/src/_Litob.o: OPT_FLAGS := -O3
+$(BUILD_DIR)/lib/src/_Ldtob.o: OPT_FLAGS := -O3
+$(BUILD_DIR)/lib/src/_Printf.o: OPT_FLAGS := -O3
+$(BUILD_DIR)/lib/src/sprintf.o: OPT_FLAGS := -O3
+
+# enable loop unrolling except for external.c (external.c might also have used
+# unrolling, but it makes one loop harder to match)
+$(BUILD_DIR)/src/audio/%.o: OPT_FLAGS := -O2
+$(BUILD_DIR)/src/audio/load.o: OPT_FLAGS := -O2
+$(BUILD_DIR)/src/audio/external.o: OPT_FLAGS := -O2 -Wo,-loopunroll,0
+else
+
+# The source-to-source optimizer copt is enabled for audio. This makes it use
+# acpp, which needs -Wp,-+ to handle C++-style comments.
+$(BUILD_DIR)/src/audio/effects.o: OPT_FLAGS := -O2 -Wo,-loopunroll,0 -sopt,-inline=sequence_channel_process_sound,-scalaroptimize=1 -Wp,-+
+$(BUILD_DIR)/src/audio/synthesis.o: OPT_FLAGS := -O2 -sopt,-scalaroptimize=1 -Wp,-+
+#$(BUILD_DIR)/src/audio/seqplayer.o: OPT_FLAGS := -O2 -sopt,-inline_manual,-scalaroptimize=1 -Wp,-+ #-Wo,-v,-bb,-l,seqplayer_list.txt
+
+# Add a target for build/eu/src/audio/*.copt to make it easier to see debug
+$(BUILD_DIR)/src/audio/%.acpp: src/audio/%.c
+	$(QEMU_IRIX) -silent -L $(IRIX_ROOT) $(IRIX_ROOT)/usr/lib/acpp $(TARGET_CFLAGS) $(INCLUDE_CFLAGS) $(VERSION_CFLAGS) $(MATCH_CFLAGS) $(GRUCODE_CFLAGS) -D__sgi -+ $< > $@
+
+$(BUILD_DIR)/src/audio/seqplayer.copt: $(BUILD_DIR)/src/audio/seqplayer.acpp
+	$(QEMU_IRIX) -silent -L $(IRIX_ROOT) $(IRIX_ROOT)/usr/lib/copt -signed -I=$< -CMP=$@ -cp=i -scalaroptimize=1 -inline_manual
+
+$(BUILD_DIR)/src/audio/%.copt: $(BUILD_DIR)/src/audio/%.acpp
+	$(QEMU_IRIX) -silent -L $(IRIX_ROOT) $(IRIX_ROOT)/usr/lib/copt -signed -I=$< -CMP=$@ -cp=i -scalaroptimize=1
+
+endif
+endif
+
+ifeq ($(NON_MATCHING),0)
+$(GLOBAL_ASM_O_FILES): CC := $(PYTHON) tools/asm_processor/build.py $(CC) -- $(AS) $(ASFLAGS) --
+endif
+
+# Rebuild files with 'GLOBAL_ASM' if the NON_MATCHING flag changes.
+$(GLOBAL_ASM_O_FILES): $(GLOBAL_ASM_DEP).$(NON_MATCHING)
+$(GLOBAL_ASM_DEP).$(NON_MATCHING):
+	@rm -f $(GLOBAL_ASM_DEP).*
+	touch $@
+
+$(BUILD_DIR)/%.o: %.cpp
+	@$(CXX) -fsyntax-only $(CFLAGS) -MMD -MP -MT $@ -MF $(BUILD_DIR)/$*.d $<
+	$(CXX) -c $(CFLAGS) -o $@ $<
+
+$(BUILD_DIR)/%.o: %.c
+	@$(CC_CHECK) $(CC_CHECK_CFLAGS) -MMD -MP -MT $@ -MF $(BUILD_DIR)/$*.d $<
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+
+$(BUILD_DIR)/%.o: $(BUILD_DIR)/%.c
+	@$(CC_CHECK) $(CC_CHECK_CFLAGS) -MMD -MP -MT $@ -MF $(BUILD_DIR)/$*.d $<
+	$(CC) -c $(CFLAGS) -o $@ $<
+
+$(BUILD_DIR)/%.o: %.s
+	$(AS) $(ASFLAGS) -MD $(BUILD_DIR)/$*.d -o $@ $<
+
+ifeq ($(TARGET_N64),1)
+$(BUILD_DIR)/$(LD_SCRIPT): $(LD_SCRIPT)
+	$(CPP) $(VERSION_CFLAGS) -MMD -MP -MT $@ -MF $@.d -I include/ -I . -DBUILD_DIR=$(BUILD_DIR) -o $@ $<
+
+$(BUILD_DIR)/libultra.a: $(ULTRA_O_FILES)
+	$(AR) rcs -o $@ $(ULTRA_O_FILES)
+	tools/patch_libultra_math $@
+
+$(BUILD_DIR)/libgoddard.a: $(GODDARD_O_FILES)
+	$(AR) rcs -o $@ $(GODDARD_O_FILES)
+
+$(ELF): $(O_FILES) $(MIO0_OBJ_FILES) $(SOUND_OBJ_FILES) $(SEG_FILES) $(BUILD_DIR)/$(LD_SCRIPT) undefined_syms.txt $(BUILD_DIR)/libultra.a $(BUILD_DIR)/libgoddard.a
+	$(LD) -L $(BUILD_DIR) $(LDFLAGS) -o $@ $(O_FILES)$(LIBS) -lultra -lgoddard
+
+$(ROM): $(ELF)
+	$(OBJCOPY) $(OBJCOPYFLAGS) $< $(@:.z64=.bin) -O binary
+	$(N64CKSUM) $(@:.z64=.bin) $@
+
+$(BUILD_DIR)/$(TARGET).objdump: $(ELF)
+	$(OBJDUMP) -D $< > $@
+
+else
+$(EXE): $(O_FILES) $(MIO0_FILES:.mio0=.o) $(SOUND_OBJ_FILES) $(ULTRA_O_FILES) $(GODDARD_O_FILES)
+	$(LD) -L $(BUILD_DIR) -o $@ $(O_FILES) $(SOUND_OBJ_FILES) $(ULTRA_O_FILES) $(GODDARD_O_FILES) $(LDFLAGS)
+endif
+
+
+
+.PHONY: all clean distclean default diff test load libultra
+# with no prerequisites, .SECONDARY causes no intermediate target to be removed
+.SECONDARY:
+
+# Remove built-in rules, to improve performance
+MAKEFLAGS += --no-builtin-rules
+
+-include $(DEP_FILES)
+
+print-% : ; $(info $* is a $(flavor $*) variable set to [$($*)]) @true
diff --git a/enhancements/puppycam.h b/enhancements/puppycam.h
new file mode 100644
index 0000000..1caad75
--- /dev/null
+++ b/enhancements/puppycam.h
@@ -0,0 +1,63 @@
+///Some Settings for the external code.
+
+//#define NC_CODE_NOSAVE //If this is defined, this will disable saving the user settings.
+//#define NC_CODE_NOMENU //If this is defined, this will disable the settings menu. It does NOT disable saving as well, because you might want that in, regardless.
+
+#ifndef TARGET_N64
+    #define NC_CODE_NOSAVE //This gets disabled off the N64 because it's no longer using the EEPROM or the old save system.
+#endif // TARGET_N64
+
+enum newcam_flagvalues
+{
+    NC_FLAG_XTURN = 0x0001,//If this flag is set, the camera's yaw can be moved by the player.
+    NC_FLAG_YTURN = 0x0002, //If this flag is set, the camera's pitch can be moved by the player.
+    NC_FLAG_ZOOM = 0x0004, //If this flag is set, the camera's distance can be set by the player.
+    NC_FLAG_8D = 0x0008, //If this flag is set, the camera will snap to an 8 directional axis
+    NC_FLAG_4D = 0x0010, //If this flag is set, the camera will snap to a 4 directional axis
+    NC_FLAG_2D = 0x0020, //If this flag is set, the camera will stick to 2D.
+    NC_FLAG_FOCUSX = 0x0040, //If this flag is set, the camera will point towards its focus on the X axis.
+    NC_FLAG_FOCUSY = 0x0080, //If this flag is set, the camera will point towards its focus on the Y axis.
+    NC_FLAG_FOCUSZ = 0x0100, //If this flag is set, the camera will point towards its focus on the Z axis.
+    NC_FLAG_POSX = 0x0200, //If this flag is set, the camera will move along the X axis.
+    NC_FLAG_POSY = 0x0400, //If this flag is set, the camera will move along the Y axis.
+    NC_FLAG_POSZ = 0x0800, //If this flag is set, the camera will move along the Z axis.
+    NC_FLAG_COLLISION = 0x1000, //If this flag is set, the camera will collide and correct itself with terrain.
+    NC_FLAG_SLIDECORRECT = 0x2000, //If this flag is set, the camera will attempt to centre itself behind Mario whenever he's sliding.
+
+    NC_MODE_NORMAL = NC_FLAG_XTURN | NC_FLAG_YTURN | NC_FLAG_ZOOM | NC_FLAG_FOCUSX | NC_FLAG_FOCUSY | NC_FLAG_FOCUSZ | NC_FLAG_POSX | NC_FLAG_POSY | NC_FLAG_POSZ | NC_FLAG_COLLISION,
+    NC_MODE_SLIDE = NC_FLAG_XTURN | NC_FLAG_YTURN | NC_FLAG_ZOOM | NC_FLAG_FOCUSX | NC_FLAG_FOCUSY | NC_FLAG_FOCUSZ | NC_FLAG_POSX | NC_FLAG_POSY | NC_FLAG_POSZ | NC_FLAG_COLLISION | NC_FLAG_SLIDECORRECT,
+    NC_MODE_FIXED = NC_FLAG_XTURN | NC_FLAG_YTURN | NC_FLAG_ZOOM | NC_FLAG_FOCUSX | NC_FLAG_FOCUSY | NC_FLAG_FOCUSZ,
+    NC_MODE_2D = NC_FLAG_XTURN | NC_FLAG_YTURN | NC_FLAG_ZOOM | NC_FLAG_FOCUSX | NC_FLAG_FOCUSY | NC_FLAG_FOCUSZ | NC_FLAG_POSX | NC_FLAG_POSY | NC_FLAG_POSZ | NC_FLAG_COLLISION,
+    NC_MODE_8D = NC_FLAG_XTURN | NC_FLAG_YTURN | NC_FLAG_ZOOM | NC_FLAG_8D | NC_FLAG_FOCUSX | NC_FLAG_FOCUSY | NC_FLAG_FOCUSZ | NC_FLAG_POSX | NC_FLAG_POSY | NC_FLAG_POSZ | NC_FLAG_COLLISION,
+    NC_MODE_FIXED_NOMOVE = 0x0000,
+    NC_MODE_NOTURN = NC_FLAG_ZOOM | NC_FLAG_FOCUSX | NC_FLAG_FOCUSY | NC_FLAG_FOCUSZ | NC_FLAG_POSX | NC_FLAG_POSY | NC_FLAG_POSZ | NC_FLAG_COLLISION,
+    NC_MODE_NOROTATE = NC_FLAG_YTURN | NC_FLAG_ZOOM | NC_FLAG_FOCUSX | NC_FLAG_FOCUSY | NC_FLAG_FOCUSZ | NC_FLAG_POSX | NC_FLAG_POSY | NC_FLAG_POSZ | NC_FLAG_COLLISION
+
+};
+
+extern void newcam_display_options(void);
+extern void newcam_check_pause_buttons(void);
+extern void newcam_init_settings(void);
+extern void newcam_render_option_text(void);
+extern void newcam_diagnostics(void);
+
+extern u8 newcam_option_open;
+
+extern s16 newcam_sensitivityX; //How quick the camera works.
+extern s16 newcam_sensitivityY;
+extern s16 newcam_invertX;
+extern s16 newcam_invertY;
+extern s16 newcam_panlevel; //How much the camera sticks out a bit in the direction you're looking.
+extern s16 newcam_aggression; //How much the camera tries to centre itself to Mario's facing and movement.
+extern u8 newcam_active; // basically the thing that governs if newcam is on.
+extern s16 newcam_analogue;
+extern u16 newcam_intendedmode;
+extern s16 newcam_degrade;
+extern u8 newcam_xlu;
+
+extern u16 newcam_mode;
+extern s16 newcam_yaw;
+
+#ifndef TARGET_N64
+extern s16 mousepos[2];
+#endif // TARGET_N64
diff --git a/enhancements/puppycam.inc.c b/enhancements/puppycam.inc.c
new file mode 100644
index 0000000..ba975ce
--- /dev/null
+++ b/enhancements/puppycam.inc.c
@@ -0,0 +1,1049 @@
+#include "sm64.h"
+#include "game/camera.h"
+#include "game/level_update.h"
+#include "game/print.h"
+#include "engine/math_util.h"
+#include "game/segment2.h"
+#include "game/save_file.h"
+#include "puppycam.h"
+#include "include/text_strings.h"
+#include "engine/surface_collision.h"
+#include "gfx_dimensions.h"
+#ifndef TARGET_N64
+    #if defined(_WIN32) || defined(_WIN64)
+    #include "pc/controller/controller_xinput.h"
+    #else
+    #include "pc/controller/controller_sdl.h"
+    #endif
+#include "pc/configfile.h"
+#endif // TARGET_N64
+
+/**
+Quick explanation of the camera modes
+
+NC_MODE_NORMAL: Standard mode, allows dualaxial movement and free control of the camera.
+NC_MODE_FIXED: Disables control of camera, and the actual position of the camera doesn't update.
+NC_MODE_2D: Disables horizontal control of the camera and locks Mario's direction to the X axis. NYI though.
+NC_MODE_8D: 8 directional movement. Similar to standard, except the camera direction snaps to 8 directions.
+NC_MODE_FIXED_NOMOVE: Disables control and movement of the camera.
+NC_MODE_NOTURN: Disables horizontal and vertical control of the camera.
+**/
+
+//!A bunch of developer intended options, to cover every base, really.
+//define NEWCAM_DEBUG //Some print values for puppycam. Not useful anymore, but never hurts to keep em around.
+//#define nosound //If for some reason you hate the concept of audio, you can disable it.
+//#define noaccel //Disables smooth movement of the camera with the C buttons.
+
+
+//!Hardcoded camera angle stuff. They're essentially area boxes that when Mario is inside, will trigger some view changes.
+///Don't touch this btw, unless you know what you're doing, this has to be above for religious reasons.
+struct newcam_hardpos
+{
+    u8 newcam_hard_levelID;
+    u8 newcam_hard_areaID;
+    u8 newcam_hard_permaswap;
+    u16 newcam_hard_modeset;
+    s16 newcam_hard_X1;
+    s16 newcam_hard_Y1;
+    s16 newcam_hard_Z1;
+    s16 newcam_hard_X2;
+    s16 newcam_hard_Y2;
+    s16 newcam_hard_Z2;
+    s16 newcam_hard_camX;
+    s16 newcam_hard_camY;
+    s16 newcam_hard_camZ;
+    s16 newcam_hard_lookX;
+    s16 newcam_hard_lookY;
+    s16 newcam_hard_lookZ;
+};
+
+#include "puppycam_angles.inc.c"
+
+#ifdef noaccel
+    u8 accel = 255;
+    #else
+    u8 accel = 10;
+#endif // noaccel
+
+#ifndef TARGET_N64
+u8 mousemode = 0;
+s16 mousepos[2]; //The current position of the mouse.
+s16 mouselock[2]; //Where the mouse was when it got locked by controller. Moving the mouse 4 pixels away will unlock the mouse again.
+#endif // TARGET_N64
+
+s16 newcam_yaw; //Z axis rotation
+f32 newcam_yaw_acc;
+s16 newcam_tilt = 1500; //Y axis rotation
+f32 newcam_tilt_acc;
+u16 newcam_distance = 750; //The distance the camera stays from the player
+u16 newcam_distance_target = 750; //The distance the player camera tries to reach.
+f32 newcam_pos_target[3]; //The position the camera is basing calculations off. *usually* Mario.
+f32 newcam_pos[3]; //Position the camera is in the world
+f32 newcam_lookat[3]; //Position the camera is looking at
+f32 newcam_framessincec[2];
+f32 newcam_extheight = 125;
+u8 newcam_centering = 0; // The flag that depicts wether the camera's goin gto try centering.
+s16 newcam_yaw_target; // The yaw value the camera tries to set itself to when the centre flag is active. Is set to Mario's face angle.
+f32 newcam_turnwait; // The amount of time to wait after landing before allowing the camera to turn again
+f32 newcam_pan_x;
+f32 newcam_pan_z;
+u8 newcam_cstick_down = 0; //Just a value that triggers true when the player 2 stick is moved in 8 direction move to prevent holding it down.
+u8 newcam_target;
+s32 newcam_sintimer = 0;
+s16 newcam_coldist;
+u8 newcam_xlu = 255;
+s8 newcam_stick2[2];
+
+s16 newcam_sensitivityX; //How quick the camera works.
+s16 newcam_sensitivityY;
+s16 newcam_invertX; //Reverses movement of the camera axis.
+s16 newcam_invertY;
+s16 newcam_panlevel; //How much the camera sticks out a bit in the direction you're looking.
+s16 newcam_aggression ; //How much the camera tries to centre itself to Mario's facing and movement.
+s16 newcam_degrade ;
+s16 newcam_analogue = 0; //Wether to accept inputs from a player 2 joystick, and then disables C button input.
+s16 newcam_distance_values[] = {750,1250,2000};
+u8 newcam_active = 1; // basically the thing that governs if newcam is on.
+u16 newcam_mode;
+u16 newcam_intendedmode = 0; // which camera mode the camera's going to try to be in when not forced into another.
+u16 newcam_modeflags;
+
+u8 newcam_option_open = 0;
+s8 newcam_option_selection = 0;
+f32 newcam_option_timer = 0;
+u8 newcam_option_index = 0;
+u8 newcam_option_scroll = 0;
+u8 newcam_option_scroll_last = 0;
+
+#ifndef NC_CODE_NOMENU
+#if defined(VERSION_EU)
+static u8 newcam_options_fr[][64] = {{NC_ANALOGUE_FR}, {NC_CAMX_FR}, {NC_CAMY_FR}, {NC_INVERTX_FR}, {NC_INVERTY_FR}, {NC_CAMC_FR}, {NC_CAMP_FR}, {NC_CAMD_FR}};
+static u8 newcam_options_de[][64] = {{NC_ANALOGUE_DE}, {NC_CAMX_DE}, {NC_CAMY_DE}, {NC_INVERTX}, {NC_INVERTY_DE}, {NC_CAMC_DE}, {NC_CAMP_DE}, {NC_CAMD_DE}};
+static u8 newcam_flags_fr[][64] = {{NC_DISABLED_FR}, {NC_ENABLED_FR}};
+static u8 newcam_flags_de[][64] = {{NC_DISABLED_DE}, {NC_ENABLED_DE}};
+static u8 newcam_strings_fr[][64] = {{NC_BUTTON_FR}, {NC_BUTTON2_FR}, {NC_OPTION_FR}, {NC_HIGHLIGHT_L_FR}, {NC_HIGHLIGHT_R_FR}};
+static u8 newcam_strings_de[][64] = {{NC_BUTTON_DE}, {NC_BUTTON2_DE}, {NC_OPTION_DE}, {NC_HIGHLIGHT_L_DE}, {NC_HIGHLIGHT_R_DE}};
+#else
+static u8 newcam_options[][64] = {{NC_ANALOGUE}, {NC_CAMX}, {NC_CAMY}, {NC_INVERTX}, {NC_INVERTY}, {NC_CAMC}, {NC_CAMP}, {NC_CAMD}};
+static u8 newcam_flags[][64] = {{NC_DISABLED}, {NC_ENABLED}};
+static u8 newcam_strings[][64] = {{NC_BUTTON}, {NC_BUTTON2}, {NC_OPTION}, {NC_HIGHLIGHT_L}, {NC_HIGHLIGHT_R}};
+#endif
+#endif
+
+#define OPT 32 //Just a temp thing
+
+static u8 (*newcam_options_ptr)[OPT][64] = &newcam_options;
+static u8 (*newcam_flags_ptr)[OPT][64] = &newcam_flags;
+static u8 (*newcam_strings_ptr)[OPT][64] = &newcam_strings;
+
+
+static struct newcam_optionstruct
+{
+    u8 newcam_op_name; //This is the position in the newcam_options text array. It doesn't have to directly correlate with its position in the struct
+    s16 *newcam_op_var; //This is the value that the option is going to directly affect.
+    u8 newcam_op_option_start; //This is where the text array will start. Set it to 255 to have it be ignored.
+    s32 newcam_op_min; //The minimum value of the option.
+    s32 newcam_op_max; //The maximum value of the option.
+};
+
+static struct newcam_optionstruct newcam_optionvar[]=
+{ //If the min and max are 0 and 1, then the value text is used, otherwise it's ignored.
+    //No point this existing on hardware you natively get double analogue sticks.
+    #ifdef TARGET_N64
+    {/*Option Name*/ 0, /*Option Variable*/ &newcam_analogue, /*Option Value Text Start*/ 0, /*Option Minimum*/ FALSE, /*Option Maximum*/ TRUE},
+    #endif
+    {/*Option Name*/ 1, /*Option Variable*/ &newcam_sensitivityX, /*Option Value Text Start*/ 255, /*Option Minimum*/ 10, /*Option Maximum*/ 500},
+    {/*Option Name*/ 2, /*Option Variable*/ &newcam_sensitivityY, /*Option Value Text Start*/ 255, /*Option Minimum*/ 10, /*Option Maximum*/ 500},
+    {/*Option Name*/ 3, /*Option Variable*/ &newcam_invertX, /*Option Value Text Start*/ 0, /*Option Minimum*/ FALSE, /*Option Maximum*/ TRUE},
+    {/*Option Name*/ 4, /*Option Variable*/ &newcam_invertY, /*Option Value Text Start*/ 0, /*Option Minimum*/ FALSE, /*Option Maximum*/ TRUE},
+    {/*Option Name*/ 7, /*Option Variable*/ &newcam_degrade, /*Option Value Text Start*/ 255, /*Option Minimum*/ 5, /*Option Maximum*/ 100},
+    {/*Option Name*/ 5, /*Option Variable*/ &newcam_aggression, /*Option Value Text Start*/ 255, /*Option Minimum*/ 0, /*Option Maximum*/ 100},
+    {/*Option Name*/ 6, /*Option Variable*/ &newcam_panlevel, /*Option Value Text Start*/ 255, /*Option Minimum*/ 0, /*Option Maximum*/ 100},
+};
+
+//You no longer need to edit this anymore lol
+u8 newcam_total = sizeof(newcam_optionvar) / sizeof(struct newcam_optionstruct); //How many options there are in newcam_uptions.
+
+#if defined(VERSION_EU)
+static void newcam_set_language(void)
+{
+    switch (eu_get_language())
+    {
+    case 0:
+        newcam_options_ptr = &newcam_options;
+        newcam_flags_ptr = &newcam_flags;
+        newcam_strings_ptr = &newcam_strings;
+        break;
+    case 1:
+        newcam_options_ptr = &newcam_options_fr;
+        newcam_flags_ptr = &newcam_flags_fr;
+        newcam_strings_ptr = &newcam_strings_fr;
+        break;
+    case 2:
+        newcam_options_ptr = &newcam_options_de;
+        newcam_flags_ptr = &newcam_flags_de;
+        newcam_strings_ptr = &newcam_strings_de;
+        break;
+    }
+}
+#endif
+
+///This is called at every level initialisation.
+void newcam_init(struct Camera *c, u8 dv)
+{
+    #if defined(VERSION_EU)
+    newcam_set_language();
+    #endif
+    newcam_tilt = 1500;
+    newcam_distance_target = newcam_distance_values[dv];
+    newcam_yaw = -c->yaw+0x4000; //Mario and the camera's yaw have this offset between them.
+    newcam_mode = NC_MODE_NORMAL;
+    ///This here will dictate what modes the camera will start in at the beginning of a level. Below are some examples.
+    switch (gCurrLevelNum)
+    {
+        case LEVEL_BITDW: newcam_yaw = 0x4000; newcam_mode = NC_MODE_8D; newcam_tilt = 4000; newcam_distance_target = newcam_distance_values[2]; break;
+        case LEVEL_BITFS: newcam_yaw = 0x4000; newcam_mode = NC_MODE_8D; newcam_tilt = 4000; newcam_distance_target = newcam_distance_values[2]; break;
+        case LEVEL_BITS: newcam_yaw = 0x4000; newcam_mode = NC_MODE_8D; newcam_tilt = 4000; newcam_distance_target = newcam_distance_values[2]; break;
+        case LEVEL_WF: newcam_yaw = 0x4000; newcam_tilt = 2000; newcam_distance_target = newcam_distance_values[1]; break;
+        case LEVEL_RR: newcam_yaw = 0x6000; newcam_tilt = 2000; newcam_distance_target = newcam_distance_values[2]; break;
+        case LEVEL_CCM: if (gCurrAreaIndex == 1) {newcam_yaw = -0x4000; newcam_tilt = 2000; newcam_distance_target = newcam_distance_values[1];} else newcam_mode = NC_MODE_SLIDE; break;
+        case LEVEL_WDW: newcam_yaw = 0x2000; newcam_tilt = 3000; newcam_distance_target = newcam_distance_values[1]; break;
+        case 27: newcam_mode = NC_MODE_SLIDE; break;
+        case LEVEL_TTM: if (gCurrAreaIndex == 2) newcam_mode = NC_MODE_SLIDE; break;
+    }
+
+    newcam_distance = newcam_distance_target;
+    newcam_intendedmode = newcam_mode;
+    newcam_modeflags = newcam_mode;
+}
+
+static s16 newcam_clamp(s16 value, s16 max, s16 min)
+{
+    if (value >= max)
+        return max;
+    else
+    if (value <= min)
+        return min;
+    else
+        return value;
+}
+
+///These are the default settings for Puppycam. You may change them to change how they'll be set for first timers.
+void newcam_init_settings()
+{
+#ifdef TARGET_N64
+#ifndef NC_CODE_NOSAVE
+    if (save_check_firsttime())
+    {
+        save_file_get_setting();
+        newcam_sensitivityX = newcam_clamp(newcam_sensitivityX, 500, 10);
+        newcam_sensitivityY = newcam_clamp(newcam_sensitivityY, 500, 10);
+        newcam_aggression = newcam_clamp(newcam_aggression, 100, 0);
+        newcam_panlevel = newcam_clamp(newcam_panlevel, 100, 0);
+        newcam_invertX = newcam_clamp(newcam_invertX, 1, 0);
+        newcam_invertY = newcam_clamp(newcam_invertY, 1, 0);
+        newcam_degrade = newcam_clamp(newcam_degrade, 100, 10);
+    }
+    else
+    {
+#endif
+        newcam_sensitivityX = 75;
+        newcam_sensitivityY = 75;
+        newcam_aggression = 0;
+        newcam_panlevel = 75;
+        newcam_invertX = 0;
+        newcam_invertY = 0;
+        newcam_degrade = 10;
+        save_set_firsttime();
+#ifndef NC_CODE_NOSAVE
+    }
+    #endif
+    #else
+    newcam_sensitivityX = puppycam_sensitivityX;
+    newcam_sensitivityY = puppycam_sensitivityY;
+    newcam_aggression = puppycam_aggression;
+    newcam_panlevel = puppycam_panlevel;
+    newcam_invertX = puppycam_invertX;
+    newcam_invertY = puppycam_invertY;
+    newcam_degrade = puppycam_degrade;
+
+    newcam_analogue = 1;
+    #endif // TARGET_N64
+}
+
+/** Mathematic calculations. This stuffs so basic even *I* understand it lol
+Basically, it just returns a position based on angle */
+static s16 lengthdir_x(f32 length, s16 dir)
+{
+    return (s16) (length * coss(dir));
+}
+static s16 lengthdir_y(f32 length, s16 dir)
+{
+    return (s16) (length * sins(dir));
+}
+
+void newcam_diagnostics(void)
+{
+    print_text_fmt_int(32,192,"Lv %d",gCurrLevelNum);
+    print_text_fmt_int(32,176,"Area %d",gCurrAreaIndex);
+    print_text_fmt_int(32,160,"X %d",gMarioState->pos[0]);
+    print_text_fmt_int(32,144,"Y %d",gMarioState->pos[1]);
+    print_text_fmt_int(32,128,"Z %d",gMarioState->pos[2]);
+    print_text_fmt_int(32,112,"FLAGS %d",newcam_modeflags);
+    print_text_fmt_int(180,112,"INTM %d",newcam_intendedmode);
+    print_text_fmt_int(32,96,"TILT UP %d",newcam_tilt_acc);
+    print_text_fmt_int(32,80,"YAW UP %d",newcam_yaw_acc);
+    print_text_fmt_int(32,64,"YAW %d",newcam_yaw);
+    print_text_fmt_int(32,48,"TILT  %d",newcam_tilt);
+    print_text_fmt_int(32,32,"DISTANCE %d",newcam_distance);
+}
+
+static void newcam_stick_input(void)
+{
+    #ifdef TARGET_N64
+    newcam_stick2[0] = gPlayer2Controller->rawStickX;
+    newcam_stick2[1] = gPlayer2Controller->rawStickY;
+    #else
+    newcam_stick2[0] = rightstick[0]*0.625;
+    newcam_stick2[1] = rightstick[1]*0.625;
+    #endif // TARGET_N64
+}
+
+static s16 newcam_adjust_value(s16 var, s16 val, s8 max)
+{
+    if (val > 0)
+    {
+        var += val;
+        if (var > max)
+            var = max;
+    }
+    else
+    if (val < 0)
+    {
+        var += val;
+        if (var < max)
+            var = max;
+    }
+
+    return var;
+}
+
+static f32 newcam_approach_float(f32 var, f32 val, f32 inc)
+{
+    if (var < val)
+        return min(var + inc, val);
+        else
+        return max(var - inc, val);
+}
+
+static s16 newcam_approach_s16(s16 var, s16 val, s16 inc)
+{
+    if (var < val)
+        return max(var + inc, val);
+        else
+        return min(var - inc, val);
+}
+
+static f32 ivrt(u8 axis)
+{
+    if (axis == 0)
+        return 1;
+    else
+        return -1;
+}
+
+static void newcam_rotate_button(void)
+{
+    f32 intendedXMag;
+    f32 intendedYMag;
+    if ((newcam_modeflags & NC_FLAG_8D || newcam_modeflags & NC_FLAG_4D) && newcam_modeflags & NC_FLAG_XTURN) //8 directional camera rotation input for buttons.
+    {
+        if ((gPlayer1Controller->buttonPressed & L_CBUTTONS) && newcam_analogue == 0)
+        {
+            #ifndef nosound
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+            #endif
+            if (newcam_modeflags & NC_FLAG_8D)
+                newcam_yaw_target = newcam_yaw_target+(ivrt(newcam_invertX)*0x2000);
+            else
+                newcam_yaw_target = newcam_yaw_target+(ivrt(newcam_invertX)*0x4000);
+            newcam_centering = 1;
+        }
+        else
+        if ((gPlayer1Controller->buttonPressed & R_CBUTTONS) && newcam_analogue == 0)
+        {
+            #ifndef nosound
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+            #endif
+            if (newcam_modeflags & NC_FLAG_8D)
+                newcam_yaw_target = newcam_yaw_target-(ivrt(newcam_invertX)*0x2000);
+            else
+                newcam_yaw_target = newcam_yaw_target-(ivrt(newcam_invertX)*0x4000);
+            newcam_centering = 1;
+        }
+    }
+    else //Standard camera movement
+    if (newcam_modeflags & NC_FLAG_XTURN)
+    {
+        if ((gPlayer1Controller->buttonDown & L_CBUTTONS) && newcam_analogue == 0)
+            newcam_yaw_acc = newcam_adjust_value(newcam_yaw_acc,-accel, -100);
+        else if ((gPlayer1Controller->buttonDown & R_CBUTTONS) && newcam_analogue == 0)
+            newcam_yaw_acc = newcam_adjust_value(newcam_yaw_acc,accel, 100);
+        else
+        if (!newcam_analogue)
+        {
+            #ifdef noaccel
+            newcam_yaw_acc = 0;
+            #else
+            newcam_yaw_acc -= (newcam_yaw_acc*((f32)newcam_degrade/100));
+            #endif
+        }
+    }
+
+    if (gPlayer1Controller->buttonDown & U_CBUTTONS && newcam_modeflags & NC_FLAG_YTURN && newcam_analogue == 0)
+        newcam_tilt_acc = newcam_adjust_value(newcam_tilt_acc,accel, 100);
+    else if (gPlayer1Controller->buttonDown & D_CBUTTONS && newcam_modeflags & NC_FLAG_YTURN && newcam_analogue == 0)
+        newcam_tilt_acc = newcam_adjust_value(newcam_tilt_acc,-accel, -100);
+    else
+    if (!newcam_analogue)
+    {
+        #ifdef noaccel
+        newcam_tilt_acc = 0;
+        #else
+        newcam_tilt_acc -= (newcam_tilt_acc*((f32)newcam_degrade/100));
+        #endif
+    }
+
+    newcam_framessincec[0] ++;
+    newcam_framessincec[1] ++;
+    if ((gPlayer1Controller->buttonPressed & L_CBUTTONS) && newcam_modeflags & NC_FLAG_XTURN && !(newcam_modeflags & NC_FLAG_8D) && newcam_analogue == 0)
+    {
+        if (newcam_framessincec[0] < 6)
+        {
+            newcam_yaw_target = newcam_yaw+(ivrt(newcam_invertX)*0x3000);
+            newcam_centering = 1;
+            #ifndef nosound
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+            #endif
+        }
+        newcam_framessincec[0] = 0;
+    }
+    if ((gPlayer1Controller->buttonPressed & R_CBUTTONS) && newcam_modeflags & NC_FLAG_XTURN && !(newcam_modeflags & NC_FLAG_8D) && newcam_analogue == 0)
+    {
+        if (newcam_framessincec[1] < 6)
+            {
+            newcam_yaw_target = newcam_yaw-(ivrt(newcam_invertX)*0x3000);
+            newcam_centering = 1;
+            #ifndef nosound
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+            #endif
+        }
+        newcam_framessincec[1] = 0;
+    }
+
+
+    if (newcam_analogue == 1) //There's not much point in keeping this behind a check, but it wouldn't hurt, just incase any 2player shenanigans ever happen, it makes it easy to disable.
+    { //The joystick values cap at 80, so divide by 8 to get the same net result at maximum turn as the button
+        intendedXMag = newcam_stick2[0]*1.25;
+        intendedYMag = newcam_stick2[1]*1.25;
+
+        if (ABS(newcam_stick2[0]) > 20 && newcam_modeflags & NC_FLAG_XTURN)
+        {
+            if (newcam_modeflags & NC_FLAG_8D)
+            {
+                if (newcam_cstick_down == 0)
+                    {
+                    newcam_cstick_down = 1;
+                    newcam_centering = 1;
+                    #ifndef nosound
+                    play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+                    #endif
+                    if (newcam_stick2[0] > 20)
+                    {
+                        if (newcam_modeflags & NC_FLAG_8D)
+                            newcam_yaw_target = newcam_yaw_target+(ivrt(newcam_invertX)*0x2000);
+                        else
+                            newcam_yaw_target = newcam_yaw_target+(ivrt(newcam_invertX)*0x4000);
+                    }
+                    else
+                    {
+                        if (newcam_modeflags & NC_FLAG_8D)
+                            newcam_yaw_target = newcam_yaw_target-(ivrt(newcam_invertX)*0x2000);
+                        else
+                            newcam_yaw_target = newcam_yaw_target-(ivrt(newcam_invertX)*0x4000);
+                    }
+                }
+            }
+            else
+            {
+                newcam_yaw_acc = newcam_adjust_value(newcam_yaw_acc,newcam_stick2[0]*0.125, intendedXMag);
+            }
+        }
+        else
+        if (newcam_analogue)
+        {
+            newcam_cstick_down = 0;
+            newcam_yaw_acc -= (newcam_yaw_acc*((f32)newcam_degrade/100));
+        }
+
+        if (ABS(newcam_stick2[1]) > 20 && newcam_modeflags & NC_FLAG_YTURN)
+            newcam_tilt_acc = newcam_adjust_value(newcam_tilt_acc,newcam_stick2[1]*0.125, intendedYMag);
+        else
+        if (newcam_analogue)
+        {
+            newcam_tilt_acc -= (newcam_tilt_acc*((f32)newcam_degrade/100));
+        }
+    }
+}
+
+static void newcam_zoom_button(void)
+{
+    //Smoothly move the camera to the new spot.
+    if (newcam_distance > newcam_distance_target)
+    {
+        newcam_distance -= 250;
+        if (newcam_distance < newcam_distance_target)
+            newcam_distance = newcam_distance_target;
+    }
+    if (newcam_distance < newcam_distance_target)
+    {
+        newcam_distance += 250;
+        if (newcam_distance > newcam_distance_target)
+            newcam_distance = newcam_distance_target;
+    }
+
+    //When you press L and R together, set the flag for centering the camera. Afterwards, start setting the yaw to the Player's yaw at the time.
+    if (gPlayer1Controller->buttonDown & L_TRIG && gPlayer1Controller->buttonDown & R_TRIG && newcam_modeflags & NC_FLAG_ZOOM)
+    {
+        newcam_yaw_target = -gMarioState->faceAngle[1]-0x4000;
+        newcam_centering = 1;
+    }
+    else //Each time the player presses R, but NOT L the camera zooms out more, until it hits the limit and resets back to close view.
+    if (gPlayer1Controller->buttonPressed & R_TRIG && newcam_modeflags & NC_FLAG_XTURN)
+    {
+        #ifndef nosound
+        play_sound(SOUND_MENU_CLICK_CHANGE_VIEW, gDefaultSoundArgs);
+        #endif
+
+        if (newcam_distance_target == newcam_distance_values[0])
+            newcam_distance_target = newcam_distance_values[1];
+        else
+        if (newcam_distance_target == newcam_distance_values[1])
+            newcam_distance_target = newcam_distance_values[2];
+        else
+            newcam_distance_target = newcam_distance_values[0];
+
+    }
+    if (newcam_centering && newcam_modeflags & NC_FLAG_XTURN)
+    {
+        newcam_yaw = approach_s16_symmetric(newcam_yaw,newcam_yaw_target,0x800);
+        if (newcam_yaw = newcam_yaw_target)
+            newcam_centering = 0;
+    }
+    else
+        newcam_yaw_target = newcam_yaw;
+}
+
+static void newcam_update_values(void)
+{//For tilt, this just limits it so it doesn't go further than 90 degrees either way. 90 degrees is actually 16384, but can sometimes lead to issues, so I just leave it shy of 90.
+    u8 waterflag = 0;
+
+    if (newcam_modeflags & NC_FLAG_XTURN)
+        newcam_yaw -= ((newcam_yaw_acc*(newcam_sensitivityX/10))*ivrt(newcam_invertX));
+    if (((newcam_tilt <= 12000) && (newcam_tilt >= -12000)) && newcam_modeflags & NC_FLAG_YTURN)
+        newcam_tilt += ((newcam_tilt_acc*ivrt(newcam_invertY))*(newcam_sensitivityY/10));
+
+    if (newcam_tilt > 12000)
+        newcam_tilt = 12000;
+    if (newcam_tilt < -12000)
+        newcam_tilt = -12000;
+
+        if (newcam_turnwait > 0 && gMarioState->vel[1] == 0)
+        {
+            newcam_turnwait -= 1;
+            if (newcam_turnwait < 0)
+                newcam_turnwait = 0;
+        }
+        else
+        {
+        if (gMarioState->intendedMag > 0 && gMarioState->vel[1] == 0 && newcam_modeflags & NC_FLAG_XTURN && !(newcam_modeflags & NC_FLAG_8D) && !(newcam_modeflags & NC_FLAG_4D))
+            newcam_yaw = (approach_s16_symmetric(newcam_yaw,-gMarioState->faceAngle[1]-0x4000,((newcam_aggression*(ABS(gPlayer1Controller->rawStickX/10)))*(gMarioState->forwardVel/32))));
+        else
+            newcam_turnwait = 10;
+        }
+
+        if (newcam_modeflags & NC_FLAG_SLIDECORRECT)
+        {
+            switch (gMarioState->action)
+            {
+                case ACT_BUTT_SLIDE: if (gMarioState->forwardVel > 8) waterflag = 1; break;
+                case ACT_STOMACH_SLIDE: if (gMarioState->forwardVel > 8) waterflag = 1; break;
+                case ACT_HOLD_BUTT_SLIDE: if (gMarioState->forwardVel > 8) waterflag = 1; break;
+                case ACT_HOLD_STOMACH_SLIDE: if (gMarioState->forwardVel > 8) waterflag = 1; break;
+            }
+        }
+        switch (gMarioState->action)
+        {
+            case ACT_SHOT_FROM_CANNON: waterflag = 1; break;
+            case ACT_FLYING: waterflag = 1; break;
+        }
+
+        if (gMarioState->action & ACT_FLAG_SWIMMING)
+        {
+            if (gMarioState->forwardVel > 2)
+            waterflag = 1;
+        }
+
+        if (waterflag && newcam_modeflags & NC_FLAG_XTURN)
+        {
+            newcam_yaw = (approach_s16_symmetric(newcam_yaw,-gMarioState->faceAngle[1]-0x4000,(gMarioState->forwardVel*128)));
+            if ((signed)gMarioState->forwardVel > 1)
+                newcam_tilt = (approach_s16_symmetric(newcam_tilt,(-gMarioState->faceAngle[0]*0.8)+3000,(gMarioState->forwardVel*32)));
+            else
+                newcam_tilt = (approach_s16_symmetric(newcam_tilt,3000,32));
+        }
+}
+
+static void newcam_collision(void)
+{
+    struct Surface *surf;
+    Vec3f camdir;
+    Vec3f hitpos;
+
+    camdir[0] = newcam_pos[0]-newcam_lookat[0];
+    camdir[1] = newcam_pos[1]-newcam_lookat[1];
+    camdir[2] = newcam_pos[2]-newcam_lookat[2];
+
+    find_surface_on_ray(newcam_pos_target, camdir, &surf, &hitpos);
+    newcam_coldist = sqrtf((newcam_pos_target[0] - hitpos[0]) * (newcam_pos_target[0] - hitpos[0]) + (newcam_pos_target[1] - hitpos[1]) * (newcam_pos_target[1] - hitpos[1]) + (newcam_pos_target[2] - hitpos[2]) * (newcam_pos_target[2] - hitpos[2]));
+
+
+    if (surf)
+    {
+        newcam_pos[0] = hitpos[0];
+        newcam_pos[1] = approach_f32(hitpos[1],newcam_pos[1],25,-25);
+        newcam_pos[2] = hitpos[2];
+        newcam_pan_x = 0;
+        newcam_pan_z = 0;
+    }
+}
+
+static void newcam_set_pan(void)
+{
+    //Apply panning values based on Mario's direction.
+    if (gMarioState->action != ACT_HOLDING_BOWSER && gMarioState->action != ACT_SLEEPING && gMarioState->action != ACT_START_SLEEPING)
+    {
+        approach_f32_asymptotic_bool(&newcam_pan_x, lengthdir_x((160*newcam_panlevel)/100, -gMarioState->faceAngle[1]-0x4000), 0.05);
+        approach_f32_asymptotic_bool(&newcam_pan_z, lengthdir_y((160*newcam_panlevel)/100, -gMarioState->faceAngle[1]-0x4000), 0.05);
+    }
+    else
+    {
+        approach_f32_asymptotic_bool(&newcam_pan_x, 0, 0.05);
+        approach_f32_asymptotic_bool(&newcam_pan_z, 0, 0.05);
+    }
+
+    newcam_pan_x = newcam_pan_x*(min(newcam_distance/newcam_distance_target,1));
+    newcam_pan_z = newcam_pan_z*(min(newcam_distance/newcam_distance_target,1));
+}
+
+static void newcam_position_cam(void)
+{
+    f32 floorY = 0;
+    f32 floorY2 = 0;
+    s16 shakeX;
+    s16 shakeY;
+
+    if (!(gMarioState->action & ACT_FLAG_SWIMMING) && newcam_modeflags & NC_FLAG_FOCUSY && newcam_modeflags & NC_FLAG_POSY)
+        calc_y_to_curr_floor(&floorY, 1.f, 200.f, &floorY2, 0.9f, 200.f);
+
+    newcam_update_values();
+    shakeX = gLakituState.shakeMagnitude[1];
+    shakeY = gLakituState.shakeMagnitude[0];
+    //Fetch Mario's current position. Not hardcoded just for the sake of flexibility, though this specific bit is temp, because it won't always want to be focusing on Mario.
+    newcam_pos_target[0] = gMarioState->pos[0];
+    newcam_pos_target[1] = gMarioState->pos[1]+newcam_extheight;
+    newcam_pos_target[2] = gMarioState->pos[2];
+    //These will set the position of the camera to where Mario is supposed to be, minus adjustments for where the camera should be, on top of.
+    if (newcam_modeflags & NC_FLAG_POSX)
+        newcam_pos[0] = newcam_pos_target[0]+lengthdir_x(lengthdir_x(newcam_distance,newcam_tilt+shakeX),newcam_yaw+shakeY);
+    if (newcam_modeflags & NC_FLAG_POSZ)
+        newcam_pos[2] = newcam_pos_target[2]+lengthdir_y(lengthdir_x(newcam_distance,newcam_tilt+shakeX),newcam_yaw+shakeY);
+    if (newcam_modeflags & NC_FLAG_POSY)
+        newcam_pos[1] = newcam_pos_target[1]+lengthdir_y(newcam_distance,newcam_tilt+gLakituState.shakeMagnitude[0])+floorY;
+    if ((newcam_modeflags & NC_FLAG_FOCUSX) && (newcam_modeflags & NC_FLAG_FOCUSY) && (newcam_modeflags & NC_FLAG_FOCUSZ))
+        newcam_set_pan();
+    //Set where the camera wants to be looking at. This is almost always the place it's based off, too.
+    if (newcam_modeflags & NC_FLAG_FOCUSX)
+        newcam_lookat[0] = newcam_pos_target[0]-newcam_pan_x;
+    if (newcam_modeflags & NC_FLAG_FOCUSY)
+        newcam_lookat[1] = newcam_pos_target[1]+floorY2;
+    if (newcam_modeflags & NC_FLAG_FOCUSZ)
+        newcam_lookat[2] = newcam_pos_target[2]-newcam_pan_z;
+
+    if (newcam_modeflags & NC_FLAG_COLLISION)
+    newcam_collision();
+
+}
+
+//Nested if's baybeeeee
+static void newcam_find_fixed(void)
+{
+    u8 i = 0;
+    newcam_mode = newcam_intendedmode;
+    newcam_modeflags = newcam_mode;
+    for (i = 0; i < sizeof(newcam_fixedcam) / sizeof(struct newcam_hardpos); i++)
+    {
+        if (newcam_fixedcam[i].newcam_hard_levelID == gCurrLevelNum && newcam_fixedcam[i].newcam_hard_areaID == gCurrAreaIndex)
+        {//I didn't wanna just obliterate the horizontal plane of the IDE with a beefy if statement, besides, I think this runs slightly better anyway?
+            if (newcam_pos_target[0] > newcam_fixedcam[i].newcam_hard_X1)
+            if (newcam_pos_target[0] < newcam_fixedcam[i].newcam_hard_X2)
+            if (newcam_pos_target[1] > newcam_fixedcam[i].newcam_hard_Y1)
+            if (newcam_pos_target[1] < newcam_fixedcam[i].newcam_hard_Y2)
+            if (newcam_pos_target[2] > newcam_fixedcam[i].newcam_hard_Z1)
+            if (newcam_pos_target[2] < newcam_fixedcam[i].newcam_hard_Z2)
+            {
+                if (newcam_fixedcam[i].newcam_hard_permaswap)
+                    newcam_intendedmode = newcam_fixedcam[i].newcam_hard_modeset;
+                newcam_mode = newcam_fixedcam[i].newcam_hard_modeset;
+                newcam_modeflags = newcam_mode;
+
+                if (newcam_fixedcam[i].newcam_hard_camX != 32767 && !(newcam_modeflags & NC_FLAG_POSX))
+                    newcam_pos[0] = newcam_fixedcam[i].newcam_hard_camX;
+                if (newcam_fixedcam[i].newcam_hard_camY != 32767 && !(newcam_modeflags & NC_FLAG_POSY))
+                    newcam_pos[1] = newcam_fixedcam[i].newcam_hard_camY;
+                if (newcam_fixedcam[i].newcam_hard_camZ != 32767 && !(newcam_modeflags & NC_FLAG_POSZ))
+                    newcam_pos[2] = newcam_fixedcam[i].newcam_hard_camZ;
+
+                if (newcam_fixedcam[i].newcam_hard_lookX != 32767 && !(newcam_modeflags & NC_FLAG_FOCUSX))
+                    newcam_lookat[0] = newcam_fixedcam[i].newcam_hard_lookX;
+                if (newcam_fixedcam[i].newcam_hard_lookY != 32767 && !(newcam_modeflags & NC_FLAG_FOCUSY))
+                    newcam_lookat[1] = newcam_fixedcam[i].newcam_hard_lookY;
+                if (newcam_fixedcam[i].newcam_hard_lookZ != 32767 && !(newcam_modeflags & NC_FLAG_FOCUSZ))
+                    newcam_lookat[2] = newcam_fixedcam[i].newcam_hard_lookZ;
+
+                newcam_yaw = atan2s(newcam_pos[0]-newcam_pos_target[0],newcam_pos[2]-newcam_pos_target[2]);
+            }
+        }
+    }
+}
+
+static void newcam_apply_values(struct Camera *c)
+{
+
+    c->pos[0] = newcam_pos[0];
+    c->pos[1] = newcam_pos[1];
+    c->pos[2] = newcam_pos[2];
+
+    c->focus[0] = newcam_lookat[0];
+    c->focus[1] = newcam_lookat[1];
+    c->focus[2] = newcam_lookat[2];
+
+    gLakituState.pos[0] = newcam_pos[0];
+    gLakituState.pos[1] = newcam_pos[1];
+    gLakituState.pos[2] = newcam_pos[2];
+
+    gLakituState.focus[0] = newcam_lookat[0];
+    gLakituState.focus[1] = newcam_lookat[1];
+    gLakituState.focus[2] = newcam_lookat[2];
+
+    c->yaw = -newcam_yaw+0x4000;
+    gLakituState.yaw = -newcam_yaw+0x4000;
+
+    //Adds support for wing mario tower
+    if (gMarioState->floor != NULL)
+    {
+        if (gMarioState->floor->type == SURFACE_LOOK_UP_WARP) {
+            if (save_file_get_total_star_count(gCurrSaveFileNum - 1, 0, 0x18) >= 10) {
+                if (newcam_tilt < -8000 && gMarioState->forwardVel == 0) {
+                    level_trigger_warp(gMarioState, 1);
+                }
+            }
+        }
+    }
+}
+
+//If puppycam gets too close to its target, start fading it out so you don't see the inside of it.
+void newcam_fade_target_closeup(void)
+{
+    if (newcam_coldist <= 250 && (newcam_coldist-150)*2.55 < 255)
+    {
+        if ((newcam_coldist-150)*2.55 > 0)
+            newcam_xlu = (newcam_coldist-150)*2.55;
+        else
+            newcam_xlu = 0;
+    }
+    else
+        newcam_xlu = 255;
+}
+
+//The ingame cutscene system is such a spaghetti mess I actually have to resort to something as stupid as this to cover every base.
+void newcam_apply_outside_values(struct Camera *c, u8 bit)
+{
+    if (bit)
+        newcam_yaw = -gMarioState->faceAngle[1]-0x4000;
+    else
+        newcam_yaw = -c->yaw+0x4000;
+}
+
+//Main loop.
+void newcam_loop(struct Camera *c)
+{
+    newcam_stick_input();
+    newcam_rotate_button();
+    newcam_zoom_button();
+    newcam_position_cam();
+    newcam_find_fixed();
+    if (gMarioObject)
+    newcam_apply_values(c);
+    newcam_fade_target_closeup();
+
+    //Just some visual information on the values of the camera. utilises ifdef because it's better at runtime.
+    #ifdef NEWCAM_DEBUG
+    newcam_diagnostics();
+    #endif // NEWCAM_DEBUG
+
+}
+
+
+#ifndef NC_CODE_NOMENU
+//Displays a box.
+void newcam_display_box(s16 x1, s16 y1, s16 x2, s16 y2, u8 r, u8 g, u8 b)
+{
+    gDPPipeSync(gDisplayListHead++);
+    gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
+    gDPSetCycleType(gDisplayListHead++, G_CYC_FILL);
+    gDPSetFillColor(gDisplayListHead++, GPACK_RGBA5551(r, g, b, 255));
+    gDPFillRectangle(gDisplayListHead++, x1, y1, x2 - 1, y2 - 1);
+    gDPPipeSync(gDisplayListHead++);
+    gDPSetCycleType(gDisplayListHead++, G_CYC_1CYCLE);
+}
+
+//I actually took the time to redo this, properly. Lmao. Please don't bully me over this anymore :(
+void newcam_change_setting(s8 toggle)
+{
+    if (gPlayer1Controller->buttonDown & A_BUTTON)
+        toggle*= 5;
+    if (gPlayer1Controller->buttonDown & B_BUTTON)
+        toggle*= 10;
+
+    if (newcam_optionvar[newcam_option_selection].newcam_op_min == FALSE && newcam_optionvar[newcam_option_selection].newcam_op_max == TRUE)
+    {
+        *newcam_optionvar[newcam_option_selection].newcam_op_var ^= 1;
+    }
+    else
+        *newcam_optionvar[newcam_option_selection].newcam_op_var += toggle;
+    //Forgive me father, for I have sinned. I guess if you wanted a selling point for a 21:9 monitor though, "I can view this line in puppycam's code without scrolling!" can be added to it.
+    *newcam_optionvar[newcam_option_selection].newcam_op_var = newcam_clamp(*newcam_optionvar[newcam_option_selection].newcam_op_var, newcam_optionvar[newcam_option_selection].newcam_op_max, newcam_optionvar[newcam_option_selection].newcam_op_min);
+}
+
+void newcam_text(s16 x, s16 y, u8 str[], u8 col)
+{
+    u8 textX;
+    textX = get_str_x_pos_from_center(x,str,10.0f);
+    gDPSetEnvColor(gDisplayListHead++, 0, 0, 0, 255);
+    print_generic_string(textX+1,y-1,str);
+    if (col != 0)
+    {
+        gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    }
+    else
+    {
+        gDPSetEnvColor(gDisplayListHead++, 255, 32, 32, 255);
+    }
+    print_generic_string(textX,y,str);
+}
+
+//Options menu
+void newcam_display_options()
+{
+    u8 i = 0;
+    u8 newstring[32];
+    s16 scroll;
+    s16 scrollpos;
+    s16 var;
+    u16 maxvar;
+    u16 minvar;
+    f32 newcam_sinpos;
+    gSPDisplayList(gDisplayListHead++, dl_rgba16_text_begin);
+    gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    print_hud_lut_string(HUD_LUT_GLOBAL, 64, 40, (*newcam_strings_ptr)[2]);
+    gSPDisplayList(gDisplayListHead++, dl_rgba16_text_end);
+
+    if (newcam_total>4)
+    {
+        newcam_display_box(272,90,280,208,0x80,0x80,0x80);
+        scrollpos = (54)*((f32)newcam_option_scroll/(newcam_total-4));
+        newcam_display_box(272,90+scrollpos,280,154+scrollpos,0xFF,0xFF,0xFF);
+    }
+
+
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 80, SCREEN_WIDTH, SCREEN_HEIGHT);
+    for (i = 0; i < newcam_total; i++)
+    {
+        scroll = 140-(32*i)+(newcam_option_scroll*32);
+        if (scroll <= 140 && scroll > 32)
+        {
+            newcam_text(160,scroll,(*newcam_options_ptr)[newcam_optionvar[i].newcam_op_name],newcam_option_selection-i);
+            if (newcam_optionvar[i].newcam_op_option_start != 255)
+            {
+                var = *newcam_optionvar[i].newcam_op_var;
+                newcam_text(160,scroll-12,(*newcam_flags_ptr)[var+newcam_optionvar[i].newcam_op_option_start],newcam_option_selection-i);
+            }
+            else
+            {
+                int_to_str(*newcam_optionvar[i].newcam_op_var,newstring);
+                newcam_text(160,scroll-12,newstring,newcam_option_selection-i);
+                newcam_display_box(96,111+(32*i)-(newcam_option_scroll*32),224,117+(32*i)-(newcam_option_scroll*32),0x80,0x80,0x80);
+                maxvar = newcam_optionvar[i].newcam_op_max - newcam_optionvar[i].newcam_op_min;
+                minvar = *newcam_optionvar[i].newcam_op_var - newcam_optionvar[i].newcam_op_min;
+                newcam_display_box(96,111+(32*i)-(newcam_option_scroll*32),96+(((f32)minvar/maxvar)*128),117+(32*i)-(newcam_option_scroll*32),0xFF,0xFF,0xFF);
+                newcam_display_box(94+(((f32)minvar/maxvar)*128),109+(32*i)-(newcam_option_scroll*32),98+(((f32)minvar/maxvar)*128),119+(32*i)-(newcam_option_scroll*32),0xFF,0x0,0x0);
+                gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
+            }
+        }
+    }
+    newcam_sinpos = sins(newcam_sintimer*5000)*4;
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
+    gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    print_generic_string(80-newcam_sinpos, 132-(32*(newcam_option_selection-newcam_option_scroll)),  (*newcam_strings_ptr)[3]);
+    print_generic_string(232+newcam_sinpos, 132-(32*(newcam_option_selection-newcam_option_scroll)),  (*newcam_strings_ptr)[4]);
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_end);
+}
+
+//This has been separated for interesting reasons. Don't question it.
+void newcam_render_option_text(void)
+{
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
+    newcam_text(278,212,(*newcam_strings_ptr)[newcam_option_open],1);
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_end);
+}
+
+
+#ifndef TARGET_N64
+void newcam_mouse_handler(void)
+{
+    //If the cursor moves an amount from the locked position, that isn't just the mouse getting the slightest movement from time manipulation, then it enables mouse input.
+    if ((mousepos[0] - mouselock[0] < 4 || mousepos[1] - mouselock[1] < 4) && !mousemode)
+        mousemode = 1;
+
+    //If the controller even dares to have an input, then the mouse backs the hell down and lets the controller take the wheel.
+    if (gPlayer1Controller->buttonDown || gPlayer1Controller->stickMag|| gPlayer2Controller->stickMag)
+    {
+        mousemode = 0;
+        mouselock[0] = mousepos[0];
+        mouselock[1] = mousepos[1];
+    }
+}
+
+void newcam_config_save(void)
+{
+    puppycam_sensitivityX = newcam_sensitivityX;
+    puppycam_sensitivityY = newcam_sensitivityY;
+    puppycam_aggression = newcam_aggression;
+    puppycam_panlevel = newcam_panlevel;
+    puppycam_invertX = newcam_invertX;
+    puppycam_invertY = newcam_invertY;
+    puppycam_degrade = newcam_degrade;
+
+    configfile_save("sm64config.txt");
+}
+#endif
+
+void newcam_check_pause_buttons()
+{
+    if (gPlayer1Controller->buttonPressed & R_TRIG)
+    {
+            #ifndef nosound
+            play_sound(SOUND_MENU_CHANGE_SELECT, gDefaultSoundArgs);
+            #endif
+        if (newcam_option_open == 0)
+        {
+            newcam_option_open = 1;
+            #if defined(VERSION_EU)
+            newcam_set_language();
+            #endif
+        }
+
+        else
+        {
+            newcam_option_open = 0;
+            #ifdef TARGET_N64
+            save_file_set_setting();
+            #else
+            newcam_config_save();
+            #endif
+        }
+    }
+
+    if (newcam_option_open)
+    {
+        newcam_sintimer++;
+        #ifndef TARGET_N64
+        if (mousemode)
+        {
+            //newcam_option_index = 140-(32*i)+(newcam_option_scroll*32);
+        }
+        #endif
+        if (ABS(gPlayer1Controller->rawStickY) > 60 || gPlayer1Controller->buttonDown & U_JPAD || gPlayer1Controller->buttonDown & D_JPAD)
+        {
+            newcam_option_timer -= 1;
+            if (newcam_option_timer <= 0)
+            {
+                switch (newcam_option_index)
+                {
+                    case 0: newcam_option_index++; newcam_option_timer += 10; break;
+                    default: newcam_option_timer += 5; break;
+                }
+                #ifndef nosound
+                play_sound(SOUND_MENU_CHANGE_SELECT, gDefaultSoundArgs);
+                #endif
+                if (gPlayer1Controller->rawStickY >= 60 || gPlayer1Controller->buttonDown & U_JPAD)
+                {
+                    newcam_option_selection--;
+                    if (newcam_option_selection < 0)
+                        newcam_option_selection = newcam_total-1;
+                }
+                else
+                if (gPlayer1Controller->rawStickY <= -60 || gPlayer1Controller->buttonDown & D_JPAD)
+                {
+                    newcam_option_selection++;
+                    if (newcam_option_selection >= newcam_total)
+                        newcam_option_selection = 0;
+                }
+            }
+        }
+        else
+        if (ABS(gPlayer1Controller->rawStickX) > 60 || gPlayer1Controller->buttonDown & L_JPAD || gPlayer1Controller->buttonDown & R_JPAD)
+        {
+            newcam_option_timer -= 1;
+            if (newcam_option_timer <= 0)
+            {
+                switch (newcam_option_index)
+                {
+                    case 0: newcam_option_index++; newcam_option_timer += 10; break;
+                    default: newcam_option_timer += 5; break;
+                }
+                #ifndef nosound
+                play_sound(SOUND_MENU_CHANGE_SELECT, gDefaultSoundArgs);
+                #endif
+                if (gPlayer1Controller->rawStickX >= 60 || gPlayer1Controller->buttonDown & R_JPAD)
+                    newcam_change_setting(1);
+                else
+                if (gPlayer1Controller->rawStickX <= -60 || gPlayer1Controller->buttonDown & L_JPAD)
+                    newcam_change_setting(-1);
+            }
+        }
+        else
+        {
+            newcam_option_timer = 0;
+            newcam_option_index = 0;
+        }
+
+        while (newcam_option_scroll - newcam_option_selection < -3 && newcam_option_selection > newcam_option_scroll)
+            newcam_option_scroll +=1;
+        while (newcam_option_scroll + newcam_option_selection > 0 && newcam_option_selection < newcam_option_scroll)
+            newcam_option_scroll -=1;
+    }
+}
+#endif
diff --git a/enhancements/puppycam_angles.inc.c b/enhancements/puppycam_angles.inc.c
new file mode 100644
index 0000000..2877f48
--- /dev/null
+++ b/enhancements/puppycam_angles.inc.c
@@ -0,0 +1,13 @@
+///This is the bit that defines where the angles happen. They're basically environment boxes that dictate camera behaviour.
+//Permaswap is a boolean that simply determines wether or not when the camera changes at this point it stays changed. 0 means it resets when you leave, and 1 means it stays changed.
+//The camera position fields accept "32767" as an ignore flag.
+struct newcam_hardpos newcam_fixedcam[] =
+{
+
+{/*Level ID*/ 16,/*Area ID*/ 1,/*Permaswap*/ 0,/*Mode*/ NC_MODE_FIXED_NOMOVE, //Standard params.
+/*X begin*/ -540,/*Y begin*/ 800,/*Z begin*/ -3500, //Where the activation box begins
+/*X end*/ 540,/*Y end*/ 2000,/*Z end*/ -1500, //Where the activation box ends.
+/*Cam X*/ 0,/*Cam Y*/ 1500,/*Cam Z*/ -1000, //The position the camera gets placed for NC_MODE_FIXED and NC_MODE_FIXED_NOMOVE
+/*Look X*/ 0,/*Look Y*/ 800,/*Look Z*/ -2500}, //The position the camera looks at for NC_MODE_FIXED_NOMOVE
+
+};
diff --git a/include/segments.h b/include/segments.h
index 8963446..f6bfa63 100644
--- a/include/segments.h
+++ b/include/segments.h
@@ -1,5 +1,7 @@
-#ifndef SEGMENTS_H
-#define SEGMENTS_H
+#ifndef _SEGMENTS_H
+#define _SEGMENTS_H
+
+#define USE_EXT_RAM
 
 /*
  * Memory addresses for segments. Ideally, this header file would not be
@@ -44,13 +46,13 @@
  */
 
 #define SEG_BUFFERS      0x8005C000 // 0x0085000 in size
-#define SEG_MAIN         0x800E1000 // 0x1328000 in size
-#define SEG_ENGINE       0x80213800 // 0x0017000 in size
-#define SEG_FRAMEBUFFERS 0x8022A800 // 0x0070800 in size
-#define SEG_POOL_START   0x8029B000 // 0x0165000 in size
+#define SEG_MAIN         0x800F1000 // 0x1328000 in size
+#define SEG_ENGINE       0x80223800 // 0x0017000 in size
+#define SEG_FRAMEBUFFERS 0x8023A800 // 0x0070800 in size
+#define SEG_POOL_START   0x802AB000 // 0x0165000 in size
 #define SEG_POOL_END     0x80800000
 #define SEG_POOL_END_4MB 0x80400000 // For the error message screen enhancement.
 #define SEG_GODDARD      SEG_POOL_START + 0x113000
 #endif
 
-#endif // SEGMENTS_H
+#endif // _SEGMENTS_H
diff --git a/include/text_strings.h.in b/include/text_strings.h.in
index 749179b..f0deb0f 100644
--- a/include/text_strings.h.in
+++ b/include/text_strings.h.in
@@ -3,6 +3,75 @@
 
 #include "text_menu_strings.h"
 
+#if defined(VERSION_JP)
+	#define NC_CAMX 				_("Camera X Sensitivity")
+    #define NC_CAMY 				_("Camera Y Sensitivity")
+	#define NC_INVERTX				_("Invert X Axis")
+	#define NC_INVERTY				_("Invert Y Axis")
+    #define NC_CAMC 				_("Camera Centre Aggression")
+	#define NC_CAMD 				_("Camera Deceleration Speed")
+    #define NC_CAMP 				_("Camera Pan Level")
+    #define NC_ENABLED 				_("Enabled")
+    #define NC_DISABLED 			_("Disabled")
+    #define NC_BUTTON 				_("[R]: Options")
+    #define NC_BUTTON2 				_("[R]: Return")
+	#define NC_OPTION 				_("PUPPYCAM OPTIONS")
+	#define NC_HIGHLIGHT_L 			_(">")
+	#define NC_HIGHLIGHT_R 			_("<")
+	#define NC_ANALOGUE				_("Analogue Camera")
+	#else
+	#define NC_CAMX 				_("Camera X Sensitivity")
+    #define NC_CAMY 				_("Camera Y Sensitivity")
+	#define NC_INVERTX				_("Invert X Axis")
+	#define NC_INVERTY				_("Invert Y Axis")
+    #define NC_CAMC 				_("Camera Centre Aggression")
+	#define NC_CAMD 				_("Camera Deceleration Speed")
+    #define NC_CAMP 				_("Camera Pan Level")
+    #define NC_ENABLED 				_("Enabled")
+    #define NC_DISABLED 			_("Disabled")
+    #define NC_BUTTON 				_("[R]: Options")
+    #define NC_BUTTON2 				_("[R]: Return")
+	#define NC_OPTION 				_("PUPPYCAM OPTIONS")
+	#define NC_HIGHLIGHT_L 			_(">")
+	#define NC_HIGHLIGHT_R 			_("<")
+	#define NC_ANALOGUE				_("Analogue Camera")
+	#endif
+	
+	#if defined(VERSION_EU)
+	
+	#define NC_CAMX_FR 				_("SensitivitÃ© de camÃ©ra X")
+    #define NC_CAMY_FR 				_("SensitivitÃ© de camÃ©ra Y")
+	#define NC_INVERTX_FR			_("Inverser l'axe X")
+	#define NC_INVERTY_FR			_("Inverser l'axe Y")
+    #define NC_CAMC_FR 				_("Centre d'agression de camÃ©ra")
+	#define NC_CAMD_FR 				_("VelocitÃ  di Decelerazione")
+    #define NC_CAMP_FR 				_("Niveau de mouvement panoramique")
+    #define NC_ENABLED_FR 			_("ActivÃ©")
+    #define NC_DISABLED_FR			_("DÃ©sactivÃ©")
+    #define NC_BUTTON_FR 			_("[R]: Options")
+    #define NC_BUTTON2_FR 			_("[R]: Retour")
+	#define NC_OPTION_FR 			_("OPTIONS PUPPYCAM")
+	#define NC_HIGHLIGHT_L_FR		_(">")
+	#define NC_HIGHLIGHT_R_FR 		_("<")
+	#define NC_ANALOGUE_FR			_("CamÃ©ra analogique")
+	
+	#define NC_CAMX_DE 				_("Kamera X Empfindlichkeit")
+    #define NC_CAMY_DE 				_("Kamera Y Empfindlichkeit")
+	#define NC_INVERTX_DE			_("X Achse umdrehen ")
+	#define NC_INVERTY_DE			_("Y Achse umdrehen ")
+    #define NC_CAMC_DE 				_("Mittengeschwindigkeit")
+	#define NC_CAMD_DE 				_("Kamera VerzÃ¶gerungsgeschwindigkeit")
+    #define NC_CAMP_DE 				_("Kamera Schwenklevel")
+    #define NC_ENABLED_DE 			_("Aktiviert")
+    #define NC_DISABLED_DE			_("Deaktiviert")
+    #define NC_BUTTON_DE 			_("[R]: Optionen")
+    #define NC_BUTTON2_DE 			_("[R]: ZurÃ¼ck")
+	#define NC_OPTION_DE 			_("PUPPYCAM OPTIONS")
+	#define NC_HIGHLIGHT_L_DE 		_(">")
+	#define NC_HIGHLIGHT_R_DE 		_("<")
+	#define NC_ANALOGUE_DE			_("Analogkamera")
+#endif
+
 /**
  * Global Symbols
  */
diff --git a/src/engine/math_util.c b/src/engine/math_util.c
index 58c5e3f..488f67d 100644
--- a/src/engine/math_util.c
+++ b/src/engine/math_util.c
@@ -49,6 +49,35 @@ void *vec3f_sum(Vec3f dest, Vec3f a, Vec3f b) {
     return &dest; //! warning: function returns address of local variable
 }
 
+/// Multiply vector 'dest' by a
+void *vec3f_mul(Vec3f dest, f32 a)
+{
+    dest[0] *= a;
+    dest[1] *= a;
+    dest[2] *= a;
+    return &dest; //! warning: function returns address of local variable
+}
+
+/// Get length of vector 'a'
+f32 vec3f_length(Vec3f a)
+{
+	return sqrtf(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
+}
+
+/// Get dot product of vectors 'a' and 'b'
+f32 vec3f_dot(Vec3f a, Vec3f b)
+{
+	return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
+}
+
+/// Make 'dest' the difference of vectors a and b.
+void *vec3f_dif(Vec3f dest, Vec3f a, Vec3f b) {
+    dest[0] = a[0] - b[0];
+    dest[1] = a[1] - b[1];
+    dest[2] = a[2] - b[2];
+    return &dest; //! warning: function returns address of local variable
+}
+
 /// Copy vector src to dest
 void *vec3s_copy(Vec3s dest, Vec3s src) {
     dest[0] = src[0];
diff --git a/src/engine/math_util.h b/src/engine/math_util.h
index cb37d52..2013402 100644
--- a/src/engine/math_util.h
+++ b/src/engine/math_util.h
@@ -32,15 +32,21 @@ extern f32 gCosineTable[];
 
 #define sqr(x) ((x) * (x))
 
+#define abs(x) ((x) < 0 ? -(x) : (x))
+
 void *vec3f_copy(Vec3f dest, Vec3f src);
 void *vec3f_set(Vec3f dest, f32 x, f32 y, f32 z);
 void *vec3f_add(Vec3f dest, Vec3f a);
 void *vec3f_sum(Vec3f dest, Vec3f a, Vec3f b);
+void *vec3f_dif(Vec3f dest, Vec3f a, Vec3f b);
+void *vec3f_mul(Vec3f dest, f32 a);
 void *vec3s_copy(Vec3s dest, Vec3s src);
 void *vec3s_set(Vec3s dest, s16 x, s16 y, s16 z);
 void *vec3s_add(Vec3s dest, Vec3s a);
 void *vec3s_sum(Vec3s dest, Vec3s a, Vec3s b);
 void *vec3s_sub(Vec3s dest, Vec3s a);
+f32 vec3f_length(Vec3f a);
+f32 vec3f_dot(Vec3f a, Vec3f b);
 void *vec3s_to_vec3f(Vec3f dest, Vec3s a);
 void *vec3f_to_vec3s(Vec3s dest, Vec3f a);
 void *find_vector_perpendicular_to_plane(Vec3f dest, Vec3f a, Vec3f b, Vec3f c);
diff --git a/src/engine/surface_collision.c b/src/engine/surface_collision.c
index 9aff62f..997aa47 100644
--- a/src/engine/surface_collision.c
+++ b/src/engine/surface_collision.c
@@ -7,6 +7,7 @@
 #include "game/object_list_processor.h"
 #include "surface_collision.h"
 #include "surface_load.h"
+#include "math_util.h"
 
 /**************************************************
  *                      WALLS                     *
@@ -775,3 +776,167 @@ s32 unused_resolve_floor_or_ceil_collisions(s32 checkCeil, f32 *px, f32 *py, f32
 
     return 0;
 }
+
+/**
+ * Raycast functions
+ */
+s32 ray_surface_intersect(Vec3f orig, Vec3f dir, f32 dir_length, struct Surface *surface, Vec3f hit_pos, f32 *length)
+{
+    Vec3f v0, v1, v2, e1, e2, h, s, q;
+    f32 a, f, u, v;
+    Vec3f add_dir;
+
+    // Get surface normal and some other stuff
+    vec3s_to_vec3f(v0, surface->vertex1);
+    vec3s_to_vec3f(v1, surface->vertex2);
+    vec3s_to_vec3f(v2, surface->vertex3);
+
+    vec3f_dif(e1, v1, v0);
+    vec3f_dif(e2, v2, v0);
+
+    vec3f_cross(h, dir, e2);
+
+    // Check if we're perpendicular from the surface
+    a = vec3f_dot(e1, h);
+    if (a > -0.00001f && a < 0.00001f)
+        return FALSE;
+
+    // Check if we're making contact with the surface
+    f = 1.0f / a;
+
+    vec3f_dif(s, orig, v0);
+    u = f * vec3f_dot(s, h);
+    if (u < 0.0f || u > 1.0f)
+        return FALSE;
+
+    vec3f_cross(q, s, e1);
+    v = f * vec3f_dot(dir, q);
+    if (v < 0.0f || u + v > 1.0f)
+        return FALSE;
+
+    // Get the length between our origin and the surface contact point
+    *length = f * vec3f_dot(e2, q);
+    if (*length <= 0.00001 || *length > dir_length)
+        return FALSE;
+
+    // Successful contact
+    vec3f_copy(add_dir, dir);
+    vec3f_mul(add_dir, *length);
+    vec3f_sum(hit_pos, orig, add_dir);
+    return TRUE;
+}
+
+void find_surface_on_ray_list(struct SurfaceNode *list, Vec3f orig, Vec3f dir, f32 dir_length, struct Surface **hit_surface, Vec3f hit_pos, f32 *max_length)
+{
+    s32 hit;
+    f32 length;
+    Vec3f chk_hit_pos;
+    f32 top, bottom;
+
+    // Get upper and lower bounds of ray
+    if (dir[1] >= 0.0f)
+    {
+        top = orig[1] + dir[1] * dir_length;
+        bottom = orig[1];
+    }
+    else
+    {
+        top = orig[1];
+        bottom = orig[1] + dir[1] * dir_length;
+    }
+
+    // Iterate through every surface of the list
+    for (; list != NULL; list = list->next)
+    {
+        // Reject surface if out of vertical bounds
+        if (list->surface->lowerY > top || list->surface->upperY < bottom)
+            continue;
+
+        // Check intersection between the ray and this surface
+        if ((hit = ray_surface_intersect(orig, dir, dir_length, list->surface, chk_hit_pos, &length)) != 0)
+        {
+            if (length <= *max_length)
+            {
+                *hit_surface = list->surface;
+                vec3f_copy(hit_pos, chk_hit_pos);
+                *max_length = length;
+            }
+        }
+    }
+}
+
+
+void find_surface_on_ray_cell(s16 cellX, s16 cellZ, Vec3f orig, Vec3f normalized_dir, f32 dir_length, struct Surface **hit_surface, Vec3f hit_pos, f32 *max_length)
+{
+	// Skip if OOB
+	if (cellX >= 0 && cellX <= 0xF && cellZ >= 0 && cellZ <= 0xF)
+	{
+		// Iterate through each surface in this partition
+		if (normalized_dir[1] > -0.99f)
+		{
+			find_surface_on_ray_list(gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_CEILS].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
+			find_surface_on_ray_list(gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_CEILS].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
+		}
+		if (normalized_dir[1] < 0.99f)
+		{
+			find_surface_on_ray_list(gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
+			find_surface_on_ray_list(gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_FLOORS].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
+		}
+		find_surface_on_ray_list(gStaticSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_WALLS].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
+		find_surface_on_ray_list(gDynamicSurfacePartition[cellZ][cellX][SPATIAL_PARTITION_WALLS].next, orig, normalized_dir, dir_length, hit_surface, hit_pos, max_length);
+	}
+}
+
+void find_surface_on_ray(Vec3f orig, Vec3f dir, struct Surface **hit_surface, Vec3f hit_pos)
+{
+    f32 max_length;
+    s16 cellZ, cellX;
+    f32 fCellZ, fCellX;
+    f32 dir_length;
+    Vec3f normalized_dir;
+    f32 step, dx, dz;
+    u32 i;
+
+    // Set that no surface has been hit
+    *hit_surface = NULL;
+    vec3f_sum(hit_pos, orig, dir);
+
+    // Get normalized direction
+    dir_length = vec3f_length(dir);
+    max_length = dir_length;
+    vec3f_copy(normalized_dir, dir);
+    vec3f_normalize(normalized_dir);
+
+    // Get our cell coordinate
+    fCellX = (orig[0] + LEVEL_BOUNDARY_MAX) / CELL_SIZE;
+    fCellZ = (orig[2] + LEVEL_BOUNDARY_MAX) / CELL_SIZE;
+    cellX = (s16)fCellX;
+    cellZ = (s16)fCellZ;
+
+    // Don't do DDA if straight down
+    if (normalized_dir[1] >= 0.99999f || normalized_dir[1] <= -0.99999f)
+    {
+		find_surface_on_ray_cell(cellX, cellZ, orig, normalized_dir, dir_length, hit_surface, hit_pos, &max_length);
+		return;
+	}
+
+    // Get cells we cross using DDA
+    if (abs(dir[0]) >= abs(dir[2]))
+        step = abs(dir[0]) / CELL_SIZE;
+    else
+        step = abs(dir[2]) / CELL_SIZE;
+
+    dx = dir[0] / step / CELL_SIZE;
+    dz = dir[2] / step / CELL_SIZE;
+
+    for (i = 0; i < step && *hit_surface == NULL; i++)
+    {
+		find_surface_on_ray_cell(cellX, cellZ, orig, normalized_dir, dir_length, hit_surface, hit_pos, &max_length);
+
+        // Move cell coordinate
+        fCellX += dx;
+        fCellZ += dz;
+        cellX = (s16)fCellX;
+        cellZ = (s16)fCellZ;
+    }
+}
diff --git a/src/engine/surface_collision.h b/src/engine/surface_collision.h
index 71898d3..6332c48 100644
--- a/src/engine/surface_collision.h
+++ b/src/engine/surface_collision.h
@@ -36,5 +36,6 @@ f32 find_floor(f32 xPos, f32 yPos, f32 zPos, struct Surface **pfloor);
 f32 find_water_level(f32 x, f32 z);
 f32 find_poison_gas_level(f32 x, f32 z);
 void debug_surface_list_info(f32 xPos, f32 zPos);
+void find_surface_on_ray(Vec3f orig, Vec3f dir, struct Surface **hit_surface, Vec3f hit_pos);
 
 #endif // SURFACE_COLLISION_H
diff --git a/src/game/camera.c b/src/game/camera.c
index 60bfb86..2e1f23f 100644
--- a/src/game/camera.c
+++ b/src/game/camera.c
@@ -700,6 +700,8 @@ f32 calc_y_to_curr_floor(f32 *posOff, f32 posMul, f32 posBound, f32 *focOff, f32
         *focOff = -focBound;
     }
 }
+//Compiler gets mad if I put this any further above. thanks refresh 7
+#include "../../enhancements/puppycam.inc.c"
 
 void focus_on_mario(Vec3f focus, Vec3f pos, f32 posYOff, f32 focYOff, f32 dist, s16 pitch, s16 yaw) {
     Vec3f marioPos;
@@ -2852,6 +2854,8 @@ void set_camera_mode(struct Camera *c, s16 mode, s16 frames) {
     struct LinearTransitionPoint *start = &sModeInfo.transitionStart;
     struct LinearTransitionPoint *end = &sModeInfo.transitionEnd;
 
+    if (mode != CAM_MODE_NEWCAM && gLakituState.mode != CAM_MODE_NEWCAM)
+    {
     if (mode == CAMERA_MODE_WATER_SURFACE && gCurrLevelArea == AREA_TTM_OUTSIDE) {
     } else {
         // Clear movement flags that would affect the transition
@@ -2895,6 +2899,7 @@ void set_camera_mode(struct Camera *c, s16 mode, s16 frames) {
         vec3f_get_dist_and_angle(start->focus, start->pos, &start->dist, &start->pitch, &start->yaw);
         vec3f_get_dist_and_angle(end->focus, end->pos, &end->dist, &end->pitch, &end->yaw);
     }
+    }
 }
 
 /**
@@ -2979,7 +2984,7 @@ void update_lakitu(struct Camera *c) {
         gLakituState.roll += sHandheldShakeRoll;
         gLakituState.roll += gLakituState.keyDanceRoll;
 
-        if (c->mode != CAMERA_MODE_C_UP && c->cutscene == 0) {
+        if (c->mode != CAMERA_MODE_C_UP && c->cutscene == 0 && c->mode != CAM_MODE_NEWCAM) {
             gCheckingSurfaceCollisionsForCamera = TRUE;
             distToFloor = find_floor(gLakituState.pos[0],
                                      gLakituState.pos[1] + 20.0f,
@@ -3012,7 +3017,7 @@ void update_camera(struct Camera *c) {
     update_camera_hud_status(c);
     if (c->cutscene == 0) {
         // Only process R_TRIG if 'fixed' is not selected in the menu
-        if (cam_select_alt_mode(0) == CAM_SELECTION_MARIO) {
+        if (cam_select_alt_mode(0) == CAM_SELECTION_MARIO && c->mode != CAM_MODE_NEWCAM) {
             if (gPlayer1Controller->buttonPressed & R_TRIG) {
                 if (set_cam_angle(0) == CAM_ANGLE_LAKITU) {
                     set_cam_angle(CAM_ANGLE_MARIO);
@@ -3050,10 +3055,18 @@ void update_camera(struct Camera *c) {
     c->mode = gLakituState.mode;
     c->defMode = gLakituState.defMode;
 
+    if (c->mode != CAM_MODE_NEWCAM)
+    {
     camera_course_processing(c);
     stub_camera_3(c);
-    sCButtonsPressed = find_c_buttons_pressed(sCButtonsPressed, gPlayer1Controller->buttonPressed,
-                                              gPlayer1Controller->buttonDown);
+    sCButtonsPressed = find_c_buttons_pressed(sCButtonsPressed, gPlayer1Controller->buttonPressed,gPlayer1Controller->buttonDown);
+    }
+
+    if (gMarioState->action == ACT_SHOT_FROM_CANNON && newcam_active)
+    {
+        gMarioState->area->camera->mode = CAM_MODE_NEWCAM;
+        gLakituState.mode = CAM_MODE_NEWCAM;
+    }
 
     if (c->cutscene != 0) {
         sYawSpeed = 0;
@@ -3091,6 +3104,10 @@ void update_camera(struct Camera *c) {
                     mode_cannon_camera(c);
                     break;
 
+                case CAM_MODE_NEWCAM:
+                    newcam_loop(c);
+                    break;
+
                 default:
                     mode_mario_camera(c);
             }
@@ -3150,6 +3167,10 @@ void update_camera(struct Camera *c) {
                 case CAMERA_MODE_SPIRAL_STAIRS:
                     mode_spiral_stairs_camera(c);
                     break;
+
+                case CAM_MODE_NEWCAM:
+                    newcam_loop(c);
+                    break;
             }
         }
     }
@@ -3425,6 +3446,13 @@ void init_camera(struct Camera *c) {
     gLakituState.nextYaw = gLakituState.yaw;
     c->yaw = gLakituState.yaw;
     c->nextYaw = gLakituState.yaw;
+
+    if (newcam_active == 1)
+    {
+        gLakituState.mode = CAM_MODE_NEWCAM;
+        gLakituState.defMode = CAM_MODE_NEWCAM;
+        newcam_init(c, 0);
+    }
 }
 
 /**
@@ -5513,6 +5541,9 @@ void set_camera_mode_8_directions(struct Camera *c) {
         s8DirModeBaseYaw = 0;
         s8DirModeYawOffset = 0;
     }
+
+    if (newcam_active == 1)
+        c->mode = CAM_MODE_NEWCAM;
 }
 
 /**
@@ -5524,6 +5555,9 @@ void set_camera_mode_boss_fight(struct Camera *c) {
         transition_to_camera_mode(c, CAMERA_MODE_BOSS_FIGHT, 15);
         sModeOffsetYaw = c->nextYaw - DEGREES(45);
     }
+
+    if (newcam_active == 1)
+        c->mode = CAM_MODE_NEWCAM;
 }
 
 void set_camera_mode_close_cam(u8 *mode) {
@@ -5531,6 +5565,9 @@ void set_camera_mode_close_cam(u8 *mode) {
         sStatusFlags &= ~CAM_FLAG_SMOOTH_MOVEMENT;
         *mode = CAMERA_MODE_CLOSE;
     }
+
+    if (newcam_active == 1)
+        *mode = CAM_MODE_NEWCAM;
 }
 
 /**
@@ -5555,6 +5592,9 @@ void set_camera_mode_radial(struct Camera *c, s16 transitionTime) {
         }
         sModeOffsetYaw = 0;
     }
+
+    if (newcam_active == 1)
+        c->mode = CAM_MODE_NEWCAM;
 }
 
 /**
@@ -6933,6 +6973,7 @@ s16 cutscene_object(u8 cutscene, struct Object *o) {
 void update_camera_yaw(struct Camera *c) {
     c->nextYaw = calculate_yaw(c->focus, c->pos);
     c->yaw = c->nextYaw;
+    newcam_apply_outside_values(c,0);
 }
 
 void cutscene_reset_spline(void) {
@@ -9201,7 +9242,12 @@ BAD_RETURN(s32) cutscene_non_painting_end(struct Camera *c) {
 
     if (c->defMode == CAMERA_MODE_CLOSE) {
         c->mode = CAMERA_MODE_CLOSE;
-    } else {
+    } else
+    if (c->defMode == CAM_MODE_NEWCAM) {
+        c->mode = CAM_MODE_NEWCAM;
+    }
+    else
+    {
         c->mode = CAMERA_MODE_FREE_ROAM;
     }
 
@@ -9957,6 +10003,7 @@ BAD_RETURN(s32) cutscene_sliding_doors_follow_mario(struct Camera *c) {
 BAD_RETURN(s32) cutscene_sliding_doors_open(struct Camera *c) {
     UNUSED u32 pad[2];
 
+    newcam_apply_outside_values(c,1);
     reset_pan_distance(c);
     cutscene_event(cutscene_sliding_doors_open_start, c, 0, 8);
     cutscene_event(cutscene_sliding_doors_open_set_cvars, c, 8, 8);
@@ -10153,7 +10200,10 @@ BAD_RETURN(s32) cutscene_unused_exit_focus_mario(struct Camera *c) {
  * Give control back to the player.
  */
 BAD_RETURN(s32) cutscene_exit_painting_end(struct Camera *c) {
-    c->mode = CAMERA_MODE_CLOSE;
+    if (newcam_active == 1)
+        c->mode = CAM_MODE_NEWCAM;
+    else
+        c->mode = CAMERA_MODE_CLOSE;
     c->cutscene = 0;
     gCutsceneTimer = CUTSCENE_STOP;
     sStatusFlags |= CAM_FLAG_SMOOTH_MOVEMENT;
@@ -10313,10 +10363,15 @@ BAD_RETURN(s32) cutscene_door_follow_mario(struct Camera *c) {
  * Ends the door cutscene. Sets the camera mode to close mode unless the default is free roam.
  */
 BAD_RETURN(s32) cutscene_door_end(struct Camera *c) {
-    if (c->defMode == CAMERA_MODE_FREE_ROAM) {
-        c->mode = CAMERA_MODE_FREE_ROAM;
-    } else {
+    if (c->defMode == CAMERA_MODE_CLOSE) {
         c->mode = CAMERA_MODE_CLOSE;
+    } else
+    if (c->defMode == CAM_MODE_NEWCAM) {
+        c->mode = CAM_MODE_NEWCAM;
+    }
+    else
+    {
+        c->mode = CAMERA_MODE_FREE_ROAM;
     }
 
     c->cutscene = 0;
diff --git a/src/game/camera.h b/src/game/camera.h
index f56ed02..36bb6d9 100644
--- a/src/game/camera.h
+++ b/src/game/camera.h
@@ -112,6 +112,7 @@
 #define CAMERA_MODE_8_DIRECTIONS      0x0E // AKA Parallel Camera, Bowser Courses & Rainbow Ride
 #define CAMERA_MODE_FREE_ROAM         0x10
 #define CAMERA_MODE_SPIRAL_STAIRS     0x11
+#define CAM_MODE_NEWCAM 0x12
 
 #define CAM_MOVE_RETURN_TO_MIDDLE       0x0001
 #define CAM_MOVE_ZOOMED_OUT             0x0002
@@ -656,8 +657,6 @@ struct LakituState
     /*0xBC*/ s16 unused;
 };
 
-// bss order hack to not affect BSS order. if possible, remove me, but it will be hard to match otherwise
-#ifndef INCLUDED_FROM_CAMERA_C
 // BSS
 extern s16 sSelectionFlags;
 extern s16 sCameraSoundFlags;
@@ -667,7 +666,6 @@ extern struct LakituState gLakituState;
 extern s16 gCameraMovementFlags;
 extern s32 gObjCutsceneDone;
 extern struct Camera *gCamera;
-#endif
 
 extern struct Object *gCutsceneFocus;
 extern struct Object *gSecondCameraFocus;
diff --git a/src/game/game_init.c b/src/game/game_init.c
index 3ce5f2d..856388b 100644
--- a/src/game/game_init.c
+++ b/src/game/game_init.c
@@ -20,6 +20,8 @@
 #include "segment_symbols.h"
 #include "thread6.h"
 #include <prevent_bss_reordering.h>
+#include "../../enhancements/puppycam.h"
+#include "pc/controller/controller_xinput.h"
 
 // FIXME: I'm not sure all of these variables belong in this file, but I don't
 // know of a good way to split them
@@ -609,6 +611,7 @@ void thread5_game_loop(UNUSED void *arg) {
 
     play_music(SEQ_PLAYER_SFX, SEQUENCE_ARGS(0, SEQ_SOUND_PLAYER), 0);
     set_sound_mode(save_file_get_sound_mode());
+    newcam_init_settings();
 
 #ifdef TARGET_N64
     rendering_init();
diff --git a/src/game/game_init.c.orig b/src/game/game_init.c.orig
new file mode 100644
index 0000000..3ce5f2d
--- /dev/null
+++ b/src/game/game_init.c.orig
@@ -0,0 +1,658 @@
+#include <ultra64.h>
+
+#include "sm64.h"
+#include "gfx_dimensions.h"
+#include "audio/external.h"
+#include "buffers/buffers.h"
+#include "buffers/gfx_output_buffer.h"
+#include "buffers/framebuffers.h"
+#include "buffers/zbuffer.h"
+#include "engine/level_script.h"
+#include "game_init.h"
+#include "main.h"
+#include "memory.h"
+#include "profiler.h"
+#include "save_file.h"
+#include "seq_ids.h"
+#include "sound_init.h"
+#include "print.h"
+#include "segment2.h"
+#include "segment_symbols.h"
+#include "thread6.h"
+#include <prevent_bss_reordering.h>
+
+// FIXME: I'm not sure all of these variables belong in this file, but I don't
+// know of a good way to split them
+struct Controller gControllers[3];
+struct SPTask *gGfxSPTask;
+Gfx *gDisplayListHead;
+u8 *gGfxPoolEnd;
+struct GfxPool *gGfxPool;
+OSContStatus gControllerStatuses[4];
+OSContPad gControllerPads[4];
+u8 gControllerBits;
+s8 gEepromProbe;
+OSMesgQueue gGameVblankQueue;
+OSMesgQueue D_80339CB8;
+OSMesg D_80339CD0;
+OSMesg D_80339CD4;
+struct VblankHandler gGameVblankHandler;
+uintptr_t gPhysicalFrameBuffers[3];
+uintptr_t gPhysicalZBuffer;
+void *D_80339CF0;
+void *D_80339CF4;
+struct MarioAnimation D_80339D10;
+struct MarioAnimation gDemo;
+UNUSED u8 filler80339D30[0x90];
+
+int unused8032C690 = 0;
+u32 gGlobalTimer = 0;
+
+static u16 sCurrFBNum = 0;
+u16 frameBufferIndex = 0;
+void (*D_8032C6A0)(void) = NULL;
+struct Controller *gPlayer1Controller = &gControllers[0];
+struct Controller *gPlayer2Controller = &gControllers[1];
+// probably debug only, see note below
+struct Controller *gPlayer3Controller = &gControllers[2];
+struct DemoInput *gCurrDemoInput = NULL; // demo input sequence
+u16 gDemoInputListID = 0;
+struct DemoInput gRecordedDemoInput = { 0 }; // possibly removed in EU. TODO: Check
+
+/**
+ * Initializes the Reality Display Processor (RDP).
+ * This function initializes settings such as texture filtering mode,
+ * scissoring, and render mode (although keep in mind that this render
+ * mode is not used in-game, where it is set in render_graph_node.c).
+ */
+void my_rdp_init(void) {
+    gDPPipeSync(gDisplayListHead++);
+    gDPPipelineMode(gDisplayListHead++, G_PM_1PRIMITIVE);
+
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
+    gDPSetCombineMode(gDisplayListHead++, G_CC_SHADE, G_CC_SHADE);
+
+    gDPSetTextureLOD(gDisplayListHead++, G_TL_TILE);
+    gDPSetTextureLUT(gDisplayListHead++, G_TT_NONE);
+    gDPSetTextureDetail(gDisplayListHead++, G_TD_CLAMP);
+    gDPSetTexturePersp(gDisplayListHead++, G_TP_PERSP);
+    gDPSetTextureFilter(gDisplayListHead++, G_TF_BILERP);
+    gDPSetTextureConvert(gDisplayListHead++, G_TC_FILT);
+
+    gDPSetCombineKey(gDisplayListHead++, G_CK_NONE);
+    gDPSetAlphaCompare(gDisplayListHead++, G_AC_NONE);
+    gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
+    gDPSetColorDither(gDisplayListHead++, G_CD_MAGICSQ);
+    gDPSetCycleType(gDisplayListHead++, G_CYC_FILL);
+
+#ifdef VERSION_SH
+    gDPSetAlphaDither(gDisplayListHead++, G_AD_PATTERN);
+#endif
+    gDPPipeSync(gDisplayListHead++);
+}
+
+/**
+ * Initializes the RSP's built-in geometry and lighting engines.
+ * Most of these (with the notable exception of gSPNumLights), are
+ * almost immediately overwritten.
+ */
+void my_rsp_init(void) {
+    gSPClearGeometryMode(gDisplayListHead++, G_SHADE | G_SHADING_SMOOTH | G_CULL_BOTH | G_FOG
+                        | G_LIGHTING | G_TEXTURE_GEN | G_TEXTURE_GEN_LINEAR | G_LOD);
+
+    gSPSetGeometryMode(gDisplayListHead++, G_SHADE | G_SHADING_SMOOTH | G_CULL_BACK | G_LIGHTING);
+
+    gSPNumLights(gDisplayListHead++, NUMLIGHTS_1);
+    gSPTexture(gDisplayListHead++, 0, 0, 0, G_TX_RENDERTILE, G_OFF);
+
+    // @bug Nintendo did not explicitly define the clipping ratio.
+    // For Fast3DEX2, this causes the dreaded warped vertices issue
+    // unless the clipping ratio is changed back to the intended value,
+    // as Fast3DEX2 uses a different initial value than Fast3D(EX).
+#ifdef F3DEX_GBI_2
+    gSPClipRatio(gDisplayListHead++, FRUSTRATIO_1);
+#endif
+}
+
+/** Clear the Z buffer. */
+void clear_z_buffer(void) {
+    gDPPipeSync(gDisplayListHead++);
+
+    gDPSetDepthSource(gDisplayListHead++, G_ZS_PIXEL);
+    gDPSetDepthImage(gDisplayListHead++, gPhysicalZBuffer);
+
+    gDPSetColorImage(gDisplayListHead++, G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WIDTH, gPhysicalZBuffer);
+    gDPSetFillColor(gDisplayListHead++,
+                    GPACK_ZDZ(G_MAXFBZ, 0) << 16 | GPACK_ZDZ(G_MAXFBZ, 0));
+
+    gDPFillRectangle(gDisplayListHead++, 0, BORDER_HEIGHT, SCREEN_WIDTH - 1,
+                     SCREEN_HEIGHT - 1 - BORDER_HEIGHT);
+}
+
+/** Sets up the final framebuffer image. */
+void display_frame_buffer(void) {
+    gDPPipeSync(gDisplayListHead++);
+
+    gDPSetCycleType(gDisplayListHead++, G_CYC_1CYCLE);
+    gDPSetColorImage(gDisplayListHead++, G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_WIDTH,
+                     gPhysicalFrameBuffers[frameBufferIndex]);
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, BORDER_HEIGHT, SCREEN_WIDTH,
+                  SCREEN_HEIGHT - BORDER_HEIGHT);
+}
+
+/** Clears the framebuffer, allowing it to be overwritten. */
+void clear_frame_buffer(s32 color) {
+    gDPPipeSync(gDisplayListHead++);
+
+    gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
+    gDPSetCycleType(gDisplayListHead++, G_CYC_FILL);
+
+    gDPSetFillColor(gDisplayListHead++, color);
+    gDPFillRectangle(gDisplayListHead++,
+                     GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(0), BORDER_HEIGHT,
+                     GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(0) - 1, SCREEN_HEIGHT - BORDER_HEIGHT - 1);
+
+    gDPPipeSync(gDisplayListHead++);
+
+    gDPSetCycleType(gDisplayListHead++, G_CYC_1CYCLE);
+}
+
+/** Clears and initializes the viewport. */
+void clear_viewport(Vp *viewport, s32 color) {
+    s16 vpUlx = (viewport->vp.vtrans[0] - viewport->vp.vscale[0]) / 4 + 1;
+    s16 vpUly = (viewport->vp.vtrans[1] - viewport->vp.vscale[1]) / 4 + 1;
+    s16 vpLrx = (viewport->vp.vtrans[0] + viewport->vp.vscale[0]) / 4 - 2;
+    s16 vpLry = (viewport->vp.vtrans[1] + viewport->vp.vscale[1]) / 4 - 2;
+
+#ifdef WIDESCREEN
+    vpUlx = GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(vpUlx);
+    vpLrx = GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(SCREEN_WIDTH - vpLrx);
+#endif
+
+    gDPPipeSync(gDisplayListHead++);
+
+    gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
+    gDPSetCycleType(gDisplayListHead++, G_CYC_FILL);
+
+    gDPSetFillColor(gDisplayListHead++, color);
+    gDPFillRectangle(gDisplayListHead++, vpUlx, vpUly, vpLrx, vpLry);
+
+    gDPPipeSync(gDisplayListHead++);
+
+    gDPSetCycleType(gDisplayListHead++, G_CYC_1CYCLE);
+}
+
+/** Draws the horizontal screen borders */
+void draw_screen_borders(void) {
+    gDPPipeSync(gDisplayListHead++);
+
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
+    gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
+    gDPSetCycleType(gDisplayListHead++, G_CYC_FILL);
+
+    gDPSetFillColor(gDisplayListHead++, GPACK_RGBA5551(0, 0, 0, 0) << 16 | GPACK_RGBA5551(0, 0, 0, 0));
+
+#if BORDER_HEIGHT != 0
+    gDPFillRectangle(gDisplayListHead++, GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(0), 0,
+                     GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(0) - 1, BORDER_HEIGHT - 1);
+    gDPFillRectangle(gDisplayListHead++,
+                     GFX_DIMENSIONS_RECT_FROM_LEFT_EDGE(0), SCREEN_HEIGHT - BORDER_HEIGHT,
+                     GFX_DIMENSIONS_RECT_FROM_RIGHT_EDGE(0) - 1, SCREEN_HEIGHT - 1);
+#endif
+}
+
+void make_viewport_clip_rect(Vp *viewport) {
+    s16 vpUlx = (viewport->vp.vtrans[0] - viewport->vp.vscale[0]) / 4 + 1;
+    s16 vpPly = (viewport->vp.vtrans[1] - viewport->vp.vscale[1]) / 4 + 1;
+    s16 vpLrx = (viewport->vp.vtrans[0] + viewport->vp.vscale[0]) / 4 - 1;
+    s16 vpLry = (viewport->vp.vtrans[1] + viewport->vp.vscale[1]) / 4 - 1;
+
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, vpUlx, vpPly, vpLrx, vpLry);
+}
+
+/**
+ * Loads the F3D microcodes.
+ * Refer to this function if you would like to load
+ * other microcodes (i.e. S2DEX).
+ */
+void create_task_structure(void) {
+    s32 entries = gDisplayListHead - gGfxPool->buffer;
+
+    gGfxSPTask->msgqueue = &D_80339CB8;
+    gGfxSPTask->msg = (OSMesg) 2;
+    gGfxSPTask->task.t.type = M_GFXTASK;
+#if TARGET_N64
+    gGfxSPTask->task.t.ucode_boot = rspF3DBootStart;
+    gGfxSPTask->task.t.ucode_boot_size = ((u8 *) rspF3DBootEnd - (u8 *) rspF3DBootStart);
+    gGfxSPTask->task.t.flags = 0;
+    gGfxSPTask->task.t.ucode = rspF3DStart;
+    gGfxSPTask->task.t.ucode_data = rspF3DDataStart;
+#endif
+    gGfxSPTask->task.t.ucode_size = SP_UCODE_SIZE; // (this size is ignored)
+    gGfxSPTask->task.t.ucode_data_size = SP_UCODE_DATA_SIZE;
+    gGfxSPTask->task.t.dram_stack = (u64 *) gGfxSPTaskStack;
+    gGfxSPTask->task.t.dram_stack_size = SP_DRAM_STACK_SIZE8;
+    gGfxSPTask->task.t.output_buff = gGfxSPTaskOutputBuffer;
+    gGfxSPTask->task.t.output_buff_size =
+        (u64 *)((u8 *) gGfxSPTaskOutputBuffer + sizeof(gGfxSPTaskOutputBuffer));
+    gGfxSPTask->task.t.data_ptr = (u64 *) &gGfxPool->buffer;
+    gGfxSPTask->task.t.data_size = entries * sizeof(Gfx);
+    gGfxSPTask->task.t.yield_data_ptr = (u64 *) gGfxSPTaskYieldBuffer;
+    gGfxSPTask->task.t.yield_data_size = OS_YIELD_DATA_SIZE;
+}
+
+/** Starts rendering the scene. */
+void init_render_image(void) {
+    move_segment_table_to_dmem();
+    my_rdp_init();
+    my_rsp_init();
+    clear_z_buffer();
+    display_frame_buffer();
+}
+
+/** Ends the master display list. */
+void end_master_display_list(void) {
+    draw_screen_borders();
+    if (gShowProfiler) {
+        draw_profiler();
+    }
+
+    gDPFullSync(gDisplayListHead++);
+    gSPEndDisplayList(gDisplayListHead++);
+
+    create_task_structure();
+}
+
+void draw_reset_bars(void) {
+    s32 sp24;
+    s32 sp20;
+    s32 fbNum;
+    u64 *sp18;
+
+    if (gResetTimer != 0 && D_8032C648 < 15) {
+        if (sCurrFBNum == 0) {
+            fbNum = 2;
+        } else {
+            fbNum = sCurrFBNum - 1;
+        }
+
+        sp18 = (u64 *) PHYSICAL_TO_VIRTUAL(gPhysicalFrameBuffers[fbNum]);
+        sp18 += D_8032C648++ * (SCREEN_WIDTH / 4);
+
+        for (sp24 = 0; sp24 < ((SCREEN_HEIGHT / 16) + 1); sp24++) {
+            // Must be on one line to match -O2
+            for (sp20 = 0; sp20 < (SCREEN_WIDTH / 4); sp20++) *sp18++ = 0;
+            sp18 += ((SCREEN_WIDTH / 4) * 14);
+        }
+    }
+
+    osWritebackDCacheAll();
+    osRecvMesg(&gGameVblankQueue, &D_80339BEC, OS_MESG_BLOCK);
+    osRecvMesg(&gGameVblankQueue, &D_80339BEC, OS_MESG_BLOCK);
+}
+
+void rendering_init(void) {
+    gGfxPool = &gGfxPools[0];
+    set_segment_base_addr(1, gGfxPool->buffer);
+    gGfxSPTask = &gGfxPool->spTask;
+    gDisplayListHead = gGfxPool->buffer;
+    gGfxPoolEnd = (u8 *) (gGfxPool->buffer + GFX_POOL_SIZE);
+    init_render_image();
+    clear_frame_buffer(0);
+    end_master_display_list();
+    send_display_list(&gGfxPool->spTask);
+
+    frameBufferIndex++;
+    gGlobalTimer++;
+}
+
+void config_gfx_pool(void) {
+    gGfxPool = &gGfxPools[gGlobalTimer % GFX_NUM_POOLS];
+    set_segment_base_addr(1, gGfxPool->buffer);
+    gGfxSPTask = &gGfxPool->spTask;
+    gDisplayListHead = gGfxPool->buffer;
+    gGfxPoolEnd = (u8 *) (gGfxPool->buffer + GFX_POOL_SIZE);
+}
+
+/** Handles vsync. */
+void display_and_vsync(void) {
+    profiler_log_thread5_time(BEFORE_DISPLAY_LISTS);
+    osRecvMesg(&D_80339CB8, &D_80339BEC, OS_MESG_BLOCK);
+    if (D_8032C6A0 != NULL) {
+        D_8032C6A0();
+        D_8032C6A0 = NULL;
+    }
+    send_display_list(&gGfxPool->spTask);
+    profiler_log_thread5_time(AFTER_DISPLAY_LISTS);
+    osRecvMesg(&gGameVblankQueue, &D_80339BEC, OS_MESG_BLOCK);
+    osViSwapBuffer((void *) PHYSICAL_TO_VIRTUAL(gPhysicalFrameBuffers[sCurrFBNum]));
+    profiler_log_thread5_time(THREAD5_END);
+    osRecvMesg(&gGameVblankQueue, &D_80339BEC, OS_MESG_BLOCK);
+    if (++sCurrFBNum == 3) {
+        sCurrFBNum = 0;
+    }
+    if (++frameBufferIndex == 3) {
+        frameBufferIndex = 0;
+    }
+    gGlobalTimer++;
+}
+
+// this function records distinct inputs over a 255-frame interval to RAM locations and was likely
+// used to record the demo sequences seen in the final game. This function is unused.
+static void record_demo(void) {
+    // record the player's button mask and current rawStickX and rawStickY.
+    u8 buttonMask =
+        ((gPlayer1Controller->buttonDown & (A_BUTTON | B_BUTTON | Z_TRIG | START_BUTTON)) >> 8)
+        | (gPlayer1Controller->buttonDown & (U_CBUTTONS | D_CBUTTONS | L_CBUTTONS | R_CBUTTONS));
+    s8 rawStickX = gPlayer1Controller->rawStickX;
+    s8 rawStickY = gPlayer1Controller->rawStickY;
+
+    // if the stick is in deadzone, set its value to 0 to
+    // nullify the effects. We do not record deadzone inputs.
+    if (rawStickX > -8 && rawStickX < 8) {
+        rawStickX = 0;
+    }
+
+    if (rawStickY > -8 && rawStickY < 8) {
+        rawStickY = 0;
+    }
+
+    // record the distinct input and timer so long as they
+    // are unique. If the timer hits 0xFF, reset the timer
+    // for the next demo input.
+    if (gRecordedDemoInput.timer == 0xFF || buttonMask != gRecordedDemoInput.buttonMask
+        || rawStickX != gRecordedDemoInput.rawStickX || rawStickY != gRecordedDemoInput.rawStickY) {
+        gRecordedDemoInput.timer = 0;
+        gRecordedDemoInput.buttonMask = buttonMask;
+        gRecordedDemoInput.rawStickX = rawStickX;
+        gRecordedDemoInput.rawStickY = rawStickY;
+    }
+    gRecordedDemoInput.timer++;
+}
+
+// take the updated controller struct and calculate
+// the new x, y, and distance floats.
+void adjust_analog_stick(struct Controller *controller) {
+    UNUSED u8 pad[8];
+
+    // reset the controller's x and y floats.
+    controller->stickX = 0;
+    controller->stickY = 0;
+
+    // modulate the rawStickX and rawStickY to be the new f32 values by adding/subtracting 6.
+    if (controller->rawStickX <= -8) {
+        controller->stickX = controller->rawStickX + 6;
+    }
+
+    if (controller->rawStickX >= 8) {
+        controller->stickX = controller->rawStickX - 6;
+    }
+
+    if (controller->rawStickY <= -8) {
+        controller->stickY = controller->rawStickY + 6;
+    }
+
+    if (controller->rawStickY >= 8) {
+        controller->stickY = controller->rawStickY - 6;
+    }
+
+    // calculate f32 magnitude from the center by vector length.
+    controller->stickMag =
+        sqrtf(controller->stickX * controller->stickX + controller->stickY * controller->stickY);
+
+    // magnitude cannot exceed 64.0f: if it does, modify the values appropriately to
+    // flatten the values down to the allowed maximum value.
+    if (controller->stickMag > 64) {
+        controller->stickX *= 64 / controller->stickMag;
+        controller->stickY *= 64 / controller->stickMag;
+        controller->stickMag = 64;
+    }
+}
+
+// if a demo sequence exists, this will run the demo
+// input list until it is complete. called every frame.
+void run_demo_inputs(void) {
+    // eliminate the unused bits.
+    gControllers[0].controllerData->button &= VALID_BUTTONS;
+
+    /*
+        Check if a demo inputs list
+        exists and if so, run the
+        active demo input list.
+    */
+    if (gCurrDemoInput != NULL) {
+        /*
+            clear player 2's inputs if they exist. Player 2's controller
+            cannot be used to influence a demo. At some point, Nintendo
+            may have planned for there to be a demo where 2 players moved
+            around instead of just one, so clearing player 2's influence from
+            the demo had to have been necessary to perform this. Co-op mode, perhaps?
+        */
+        if (gControllers[1].controllerData != NULL) {
+            gControllers[1].controllerData->stick_x = 0;
+            gControllers[1].controllerData->stick_y = 0;
+            gControllers[1].controllerData->button = 0;
+        }
+
+        // the timer variable being 0 at the current input means the demo is over.
+        // set the button to the END_DEMO mask to end the demo.
+        if (gCurrDemoInput->timer == 0) {
+            gControllers[0].controllerData->stick_x = 0;
+            gControllers[0].controllerData->stick_y = 0;
+            gControllers[0].controllerData->button = END_DEMO;
+        } else {
+            // backup the start button if it is pressed, since we don't want the
+            // demo input to override the mask where start may have been pressed.
+            u16 startPushed = gControllers[0].controllerData->button & START_BUTTON;
+
+            // perform the demo inputs by assigning the current button mask and the stick inputs.
+            gControllers[0].controllerData->stick_x = gCurrDemoInput->rawStickX;
+            gControllers[0].controllerData->stick_y = gCurrDemoInput->rawStickY;
+
+            /*
+                to assign the demo input, the button information is stored in
+                an 8-bit mask rather than a 16-bit mask. this is because only
+                A, B, Z, Start, and the C-Buttons are used in a demo, as bits
+                in that order. In order to assign the mask, we need to take the
+                upper 4 bits (A, B, Z, and Start) and shift then left by 8 to
+                match the correct input mask. We then add this to the masked
+                lower 4 bits to get the correct button mask.
+            */
+            gControllers[0].controllerData->button =
+                ((gCurrDemoInput->buttonMask & 0xF0) << 8) + ((gCurrDemoInput->buttonMask & 0xF));
+
+            // if start was pushed, put it into the demo sequence being input to
+            // end the demo.
+            gControllers[0].controllerData->button |= startPushed;
+
+            // run the current demo input's timer down. if it hits 0, advance the
+            // demo input list.
+            if (--gCurrDemoInput->timer == 0) {
+                gCurrDemoInput++;
+            }
+        }
+    }
+}
+
+// update the controller struct with available inputs if present.
+void read_controller_inputs(void) {
+    s32 i;
+
+    // if any controllers are plugged in, update the
+    // controller information.
+    if (gControllerBits) {
+        osRecvMesg(&gSIEventMesgQueue, &D_80339BEC, OS_MESG_BLOCK);
+        osContGetReadData(&gControllerPads[0]);
+#ifdef VERSION_SH
+        release_rumble_pak_control();
+#endif
+    }
+    run_demo_inputs();
+
+    for (i = 0; i < 2; i++) {
+        struct Controller *controller = &gControllers[i];
+
+        // if we're receiving inputs, update the controller struct
+        // with the new button info.
+        if (controller->controllerData != NULL) {
+            controller->rawStickX = controller->controllerData->stick_x;
+            controller->rawStickY = controller->controllerData->stick_y;
+            controller->buttonPressed = controller->controllerData->button
+                                        & (controller->controllerData->button ^ controller->buttonDown);
+            // 0.5x A presses are a good meme
+            controller->buttonDown = controller->controllerData->button;
+            adjust_analog_stick(controller);
+        } else // otherwise, if the controllerData is NULL, 0 out all of the inputs.
+        {
+            controller->rawStickX = 0;
+            controller->rawStickY = 0;
+            controller->buttonPressed = 0;
+            controller->buttonDown = 0;
+            controller->stickX = 0;
+            controller->stickY = 0;
+            controller->stickMag = 0;
+        }
+    }
+
+    // For some reason, player 1's inputs are copied to player 3's port. This
+    // potentially may have been a way the developers "recorded" the inputs
+    // for demos, despite record_demo existing.
+    gPlayer3Controller->rawStickX = gPlayer1Controller->rawStickX;
+    gPlayer3Controller->rawStickY = gPlayer1Controller->rawStickY;
+    gPlayer3Controller->stickX = gPlayer1Controller->stickX;
+    gPlayer3Controller->stickY = gPlayer1Controller->stickY;
+    gPlayer3Controller->stickMag = gPlayer1Controller->stickMag;
+    gPlayer3Controller->buttonPressed = gPlayer1Controller->buttonPressed;
+    gPlayer3Controller->buttonDown = gPlayer1Controller->buttonDown;
+}
+
+// initialize the controller structs to point at the OSCont information.
+void init_controllers(void) {
+    s16 port, cont;
+
+    // set controller 1 to point to the set of status/pads for input 1 and
+    // init the controllers.
+    gControllers[0].statusData = &gControllerStatuses[0];
+    gControllers[0].controllerData = &gControllerPads[0];
+    osContInit(&gSIEventMesgQueue, &gControllerBits, &gControllerStatuses[0]);
+
+    // strangely enough, the EEPROM probe for save data is done in this function.
+    // save pak detection?
+    gEepromProbe = osEepromProbe(&gSIEventMesgQueue);
+
+    // loop over the 4 ports and link the controller structs to the appropriate
+    // status and pad. Interestingly, although there are pointers to 3 controllers,
+    // only 2 are connected here. The third seems to have been reserved for debug
+    // purposes and was never connected in the retail ROM, thus gPlayer3Controller
+    // cannot be used, despite being referenced in various code.
+    for (cont = 0, port = 0; port < 4 && cont < 2; port++) {
+        // is controller plugged in?
+        if (gControllerBits & (1 << port)) {
+            // the game allows you to have just 1 controller plugged
+            // into any port in order to play the game. this was probably
+            // so if any of the ports didn't work, you can have controllers
+            // plugged into any of them and it will work.
+#ifdef VERSION_SH
+            gControllers[cont].port = port;
+#endif
+            gControllers[cont].statusData = &gControllerStatuses[port];
+            gControllers[cont++].controllerData = &gControllerPads[port];
+        }
+    }
+}
+
+void setup_game_memory(void) {
+    UNUSED u8 pad[8];
+
+    set_segment_base_addr(0, (void *) 0x80000000);
+    osCreateMesgQueue(&D_80339CB8, &D_80339CD4, 1);
+    osCreateMesgQueue(&gGameVblankQueue, &D_80339CD0, 1);
+    gPhysicalZBuffer = VIRTUAL_TO_PHYSICAL(gZBuffer);
+    gPhysicalFrameBuffers[0] = VIRTUAL_TO_PHYSICAL(gFrameBuffer0);
+    gPhysicalFrameBuffers[1] = VIRTUAL_TO_PHYSICAL(gFrameBuffer1);
+    gPhysicalFrameBuffers[2] = VIRTUAL_TO_PHYSICAL(gFrameBuffer2);
+    D_80339CF0 = main_pool_alloc(0x4000, MEMORY_POOL_LEFT);
+    set_segment_base_addr(17, (void *) D_80339CF0);
+    func_80278A78(&D_80339D10, gMarioAnims, D_80339CF0);
+    D_80339CF4 = main_pool_alloc(2048, MEMORY_POOL_LEFT);
+    set_segment_base_addr(24, (void *) D_80339CF4);
+    func_80278A78(&gDemo, gDemoInputs, D_80339CF4);
+    load_segment(0x10, _entrySegmentRomStart, _entrySegmentRomEnd, MEMORY_POOL_LEFT);
+    load_segment_decompress(2, _segment2_mio0SegmentRomStart, _segment2_mio0SegmentRomEnd);
+}
+
+#ifndef TARGET_N64
+static struct LevelCommand *levelCommandAddr;
+#endif
+
+// main game loop thread. runs forever as long as the game
+// continues.
+void thread5_game_loop(UNUSED void *arg) {
+#ifdef TARGET_N64
+    struct LevelCommand *levelCommandAddr;
+#endif
+
+    setup_game_memory();
+#ifdef VERSION_SH
+    init_rumble_pak_scheduler_queue();
+#endif
+    init_controllers();
+#ifdef VERSION_SH
+    create_thread_6();
+#endif
+    save_file_load_all();
+
+    set_vblank_handler(2, &gGameVblankHandler, &gGameVblankQueue, (OSMesg) 1);
+
+    // point levelCommandAddr to the entry point into the level script data.
+    levelCommandAddr = segmented_to_virtual(level_script_entry);
+
+    play_music(SEQ_PLAYER_SFX, SEQUENCE_ARGS(0, SEQ_SOUND_PLAYER), 0);
+    set_sound_mode(save_file_get_sound_mode());
+
+#ifdef TARGET_N64
+    rendering_init();
+
+    while (1) {
+#else
+    gGlobalTimer++;
+}
+
+void game_loop_one_iteration(void) {
+#endif
+        // if the reset timer is active, run the process to reset the game.
+        if (gResetTimer) {
+            draw_reset_bars();
+#ifdef TARGET_N64
+            continue;
+#else
+            return;
+#endif
+        }
+        profiler_log_thread5_time(THREAD5_START);
+
+        // if any controllers are plugged in, start read the data for when
+        // read_controller_inputs is called later.
+        if (gControllerBits) {
+#ifdef VERSION_SH
+            block_until_rumble_pak_free();
+#endif
+            osContStartReadData(&gSIEventMesgQueue);
+        }
+
+        audio_game_loop_tick();
+        config_gfx_pool();
+        read_controller_inputs();
+        levelCommandAddr = level_script_execute(levelCommandAddr);
+        display_and_vsync();
+
+        // when debug info is enabled, print the "BUF %d" information.
+        if (gShowDebugText) {
+            // subtract the end of the gfx pool with the display list to obtain the
+            // amount of free space remaining.
+            print_text_fmt_int(180, 20, "BUF %d", gGfxPoolEnd - (u8 *) gDisplayListHead);
+        }
+#ifdef TARGET_N64
+    }
+#endif
+}
diff --git a/src/game/hud.c b/src/game/hud.c
index 8d4daa5..c1f2099 100644
--- a/src/game/hud.c
+++ b/src/game/hud.c
@@ -13,6 +13,7 @@
 #include "area.h"
 #include "save_file.h"
 #include "print.h"
+#include "../../enhancements/puppycam.h"
 
 /* @file hud.c
  * This file implements HUD rendering and power meter animations.
@@ -469,7 +470,8 @@ void render_hud(void) {
 
         if (hudDisplayFlags & HUD_DISPLAY_FLAG_CAMERA_AND_POWER) {
             render_hud_power_meter();
-            render_hud_camera_status();
+            if (!newcam_active)
+                render_hud_camera_status();
         }
 
         if (hudDisplayFlags & HUD_DISPLAY_FLAG_TIMER) {
diff --git a/src/game/ingame_menu.c b/src/game/ingame_menu.c
index b9a43df..f6f2d7f 100644
--- a/src/game/ingame_menu.c
+++ b/src/game/ingame_menu.c
@@ -22,6 +22,7 @@
 #include "sm64.h"
 #include "text_strings.h"
 #include "types.h"
+#include "../../enhancements/puppycam.h"
 
 u16 gDialogColorFadeTimer;
 s8 gLastDialogLineNum;
@@ -2603,7 +2604,10 @@ s16 render_pause_courses_and_castle(void) {
 #ifdef VERSION_EU
     gInGameLanguage = eu_get_language();
 #endif
-
+    #ifndef NC_CODE_NOMENU
+    if (newcam_option_open == 0)
+    {
+    #endif
     switch (gDialogBoxState) {
         case DIALOG_STATE_OPENING:
             gDialogLineNum = 1;
@@ -2679,6 +2683,16 @@ s16 render_pause_courses_and_castle(void) {
     if (gDialogTextAlpha < 250) {
         gDialogTextAlpha += 25;
     }
+    #ifndef NC_CODE_NOMENU
+    }
+    else
+    {
+        shade_screen();
+        newcam_display_options();
+    }
+    newcam_check_pause_buttons();
+    newcam_render_option_text();
+    #endif
 
     return 0;
 }
diff --git a/src/game/mario.c b/src/game/mario.c
index ecb4613..59a307b 100644
--- a/src/game/mario.c
+++ b/src/game/mario.c
@@ -33,6 +33,7 @@
 #include "save_file.h"
 #include "sound_init.h"
 #include "thread6.h"
+#include "../../enhancements/puppycam.h"
 
 u32 unused80339F10;
 s8 filler80339F1C[20];
@@ -1306,7 +1307,10 @@ void update_mario_joystick_inputs(struct MarioState *m) {
     }
 
     if (m->intendedMag > 0.0f) {
-        m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
+        if (gLakituState.mode != CAM_MODE_NEWCAM)
+            m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
+        else
+            m->intendedYaw = atan2s(-controller->stickY, controller->stickX)-newcam_yaw+0x4000;
         m->input |= INPUT_NONZERO_ANALOG;
     } else {
         m->intendedYaw = m->faceAngle[1];
@@ -1617,7 +1621,7 @@ void mario_update_hitbox_and_cap_model(struct MarioState *m) {
     struct MarioBodyState *bodyState = m->marioBodyState;
     s32 flags = update_and_return_cap_flags(m);
 
-    if (flags & MARIO_VANISH_CAP) {
+    if (flags & MARIO_VANISH_CAP || newcam_xlu < 255) {
         bodyState->modelState = MODEL_STATE_NOISE_ALPHA;
     }
 
diff --git a/src/game/mario_misc.c b/src/game/mario_misc.c
index 6095b6e..c1bad80 100644
--- a/src/game/mario_misc.c
+++ b/src/game/mario_misc.c
@@ -23,6 +23,7 @@
 #include "save_file.h"
 #include "skybox.h"
 #include "sound_init.h"
+#include "../../enhancements/puppycam.h"
 
 #define TOAD_STAR_1_REQUIREMENT 12
 #define TOAD_STAR_2_REQUIREMENT 25
@@ -296,12 +297,45 @@ void bhv_unlock_door_star_loop(void) {
     }
 }
 
+static u32 find_capflag(struct MarioState *m) {
+    u32 flags = m->flags;
+    u64 sCapFlickerFrames = 0x4444449249255555;
+    u32 action;
+
+    if (m->capTimer > 0) {
+        action = m->action;
+
+        if (m->capTimer == 0) {
+
+            m->flags &= ~(MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP);
+            if ((m->flags & (MARIO_NORMAL_CAP | MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP))
+                == 0) {
+                m->flags &= ~MARIO_CAP_ON_HEAD;
+            }
+        }
+
+        // This code flickers the cap through a long binary string, increasing in how
+        // common it flickers near the end.
+        if ((m->capTimer < 0x40) && ((1ULL << m->capTimer) & sCapFlickerFrames)) {
+            flags &= ~(MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP);
+            if ((flags & (MARIO_NORMAL_CAP | MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP))
+                == 0) {
+                flags &= ~MARIO_CAP_ON_HEAD;
+            }
+        }
+    }
+
+    return flags;
+}
+
 /**
  * Generate a display list that sets the correct blend mode and color for mirror Mario.
  */
 static Gfx *make_gfx_mario_alpha(struct GraphNodeGenerated *node, s16 alpha) {
     Gfx *gfx;
     Gfx *gfxHead = NULL;
+    u8 alphaBias;
+    s32 flags = find_capflag(gMarioState);
 
     if (alpha == 255) {
         node->fnNode.node.flags = (node->fnNode.node.flags & 0xFF) | (LAYER_OPAQUE << 8);
@@ -311,9 +345,17 @@ static Gfx *make_gfx_mario_alpha(struct GraphNodeGenerated *node, s16 alpha) {
         node->fnNode.node.flags = (node->fnNode.node.flags & 0xFF) | (LAYER_TRANSPARENT << 8);
         gfxHead = alloc_display_list(3 * sizeof(*gfxHead));
         gfx = gfxHead;
-        gDPSetAlphaCompare(gfx++, G_AC_DITHER);
+        if (flags & MARIO_VANISH_CAP || gMarioState->flags & MARIO_TELEPORTING)
+        {
+            gDPSetAlphaCompare(gfx++, G_AC_DITHER);
+        }
+        else
+        {
+            gDPSetAlphaCompare(gfx++, G_AC_NONE);
+        }
     }
-    gDPSetEnvColor(gfx++, 255, 255, 255, alpha);
+    alphaBias = min(alpha, newcam_xlu);
+    gDPSetEnvColor(gfx++, 255, 255, 255, alphaBias);
     gSPEndDisplayList(gfx);
     return gfxHead;
 }
diff --git a/src/game/save_file.c b/src/game/save_file.c
index 4748b99..bb9f149 100644
--- a/src/game/save_file.c
+++ b/src/game/save_file.c
@@ -11,11 +11,13 @@
 #include "level_table.h"
 #include "course_table.h"
 #include "thread6.h"
+#include "../../enhancements/puppycam.h"
 
 #define MENU_DATA_MAGIC 0x4849
 #define SAVE_FILE_MAGIC 0x4441
 
-STATIC_ASSERT(sizeof(struct SaveBuffer) == EEPROM_SIZE, "eeprom buffer size must match");
+STATIC_ASSERT(sizeof(struct SaveBuffer) <= EEPROM_SIZE, "eeprom buffer size higher than intended");
+STATIC_ASSERT(sizeof(struct SaveBuffer) >= EEPROM_SIZE, "eeprom buffer size lower than intended");
 
 extern struct SaveBuffer gSaveBuffer;
 
@@ -565,6 +567,51 @@ u16 save_file_get_sound_mode(void) {
     return gSaveBuffer.menuData[0].soundMode;
 }
 
+#ifndef NC_CODE_NOSAVE
+void save_file_set_setting(void) {
+
+    gSaveBuffer.menuData[0].camx = (s16)newcam_sensitivityX;
+    gSaveBuffer.menuData[0].camy = (s16)newcam_sensitivityY;
+    gSaveBuffer.menuData[0].invertx = (s16)newcam_invertX;
+    gSaveBuffer.menuData[0].inverty = (s16)newcam_invertY;
+    gSaveBuffer.menuData[0].camc = (s16)newcam_aggression;
+    gSaveBuffer.menuData[0].camp = (s16)newcam_panlevel;
+    gSaveBuffer.menuData[0].analogue = (s16)newcam_analogue;
+    gSaveBuffer.menuData[0].degrade = (s16)newcam_degrade;
+
+    gSaveBuffer.menuData[0].firsttime = 1;
+
+
+    gMainMenuDataModified = TRUE;
+    save_main_menu_data();
+}
+
+void save_file_get_setting(void) {
+        newcam_sensitivityX = gSaveBuffer.menuData[0].camx;
+        newcam_sensitivityY = gSaveBuffer.menuData[0].camy;
+        newcam_invertX = gSaveBuffer.menuData[0].invertx;
+        newcam_invertY = gSaveBuffer.menuData[0].inverty;
+        newcam_aggression = gSaveBuffer.menuData[0].camc;
+        newcam_panlevel = gSaveBuffer.menuData[0].camp;
+        newcam_analogue = gSaveBuffer.menuData[0].analogue;
+        newcam_degrade = gSaveBuffer.menuData[0].degrade;
+}
+
+u8 save_check_firsttime(void)
+{
+    return gSaveBuffer.menuData[0].firsttime;
+}
+
+
+void save_set_firsttime(void)
+{
+    gSaveBuffer.menuData[0].firsttime = 1;
+
+    gMainMenuDataModified = TRUE;
+    save_main_menu_data();
+}
+#endif
+
 void save_file_move_cap_to_default_location(void) {
     if (save_file_get_flags() & SAVE_FLAG_CAP_ON_GROUND) {
         switch (gSaveBuffer.files[gCurrSaveFileNum - 1][0].capLevel) {
diff --git a/src/game/save_file.h b/src/game/save_file.h
index 3ee5a19..824ee79 100644
--- a/src/game/save_file.h
+++ b/src/game/save_file.h
@@ -8,7 +8,12 @@
 
 #include "course_table.h"
 
-#define EEPROM_SIZE 0x200
+#ifndef NC_CODE_NOSAVE
+    #define EEPROM_SIZE 0x800
+#else
+    #define EEPROM_SIZE 0x200
+#endif
+
 #define NUM_SAVE_FILES 4
 
 struct SaveBlockSignature
@@ -52,16 +57,28 @@ struct MainMenuSaveData
     // on the high score screen.
     u32 coinScoreAges[NUM_SAVE_FILES];
     u16 soundMode;
-
+    #ifndef NC_CODE_NOSAVE
+    s16 camx;
+    s16 camy;
+    s16 analogue;
+    s16 invertx;
+    s16 inverty;
+    s16 camc;
+    s16 camp;
+    s16 firsttime;
+    s16 degrade;
+    #endif
 #ifdef VERSION_EU
     u16 language;
 #define SUBTRAHEND 8
 #else
-#define SUBTRAHEND 6
+#define SUBTRAHEND 15
 #endif
 
+    #ifdef NC_CODE_NOSAVE
     // Pad to match the EEPROM size of 0x200 (10 bytes on JP/US, 8 bytes on EU)
     u8 filler[EEPROM_SIZE / 2 - SUBTRAHEND - NUM_SAVE_FILES * (4 + sizeof(struct SaveFile))];
+    #endif
 
     struct SaveBlockSignature signature;
 };
@@ -72,6 +89,11 @@ struct SaveBuffer
     struct SaveFile files[NUM_SAVE_FILES][2];
     // The main menu data has two copies. If one is bad, the other is used as a backup.
     struct MainMenuSaveData menuData[2];
+    #ifndef NC_CODE_NOSAVE
+    //u8 filler[1520]; //!I still haven't done an algorithm for this yet lol
+    ///I think I figured it out lol
+    u8 filler[EEPROM_SIZE - ((NUM_SAVE_FILES*(sizeof(struct SaveFile))+sizeof(struct MainMenuSaveData))*2)];
+    #endif
 };
 
 extern u8 gLastCompletedCourseNum;
@@ -144,6 +166,12 @@ s32 save_file_get_cap_pos(Vec3s capPos);
 void save_file_set_sound_mode(u16 mode);
 u16 save_file_get_sound_mode(void);
 void save_file_move_cap_to_default_location(void);
+#ifndef NC_CODE_NOSAVE
+void save_set_firsttime(void);
+u8 save_check_firsttime(void);
+void save_file_get_setting(void);
+void save_file_set_setting(void);
+#endif
 
 void disable_warp_checkpoint(void);
 void check_if_should_set_warp_checkpoint(struct WarpNode *warpNode);
diff --git a/src/pc/configfile.c b/src/pc/configfile.c
index 10ff1e6..49488ab 100644
--- a/src/pc/configfile.c
+++ b/src/pc/configfile.c
@@ -45,6 +45,15 @@ unsigned int configKeyStickDown  = 0x1F;
 unsigned int configKeyStickLeft  = 0x1E;
 unsigned int configKeyStickRight = 0x20;
 
+unsigned int puppycam_sensitivityX = 75;
+unsigned int puppycam_sensitivityY = 75;
+unsigned int puppycam_invertX = 0;
+unsigned int puppycam_invertY = 0;
+unsigned int puppycam_degrade = 10;
+unsigned int puppycam_aggression = 0;
+unsigned int puppycam_panlevel = 75;
+
+
 
 static const struct ConfigOption options[] = {
     {.name = "fullscreen",     .type = CONFIG_TYPE_BOOL, .boolValue = &configFullscreen},
@@ -61,6 +70,15 @@ static const struct ConfigOption options[] = {
     {.name = "key_stickdown",  .type = CONFIG_TYPE_UINT, .uintValue = &configKeyStickDown},
     {.name = "key_stickleft",  .type = CONFIG_TYPE_UINT, .uintValue = &configKeyStickLeft},
     {.name = "key_stickright", .type = CONFIG_TYPE_UINT, .uintValue = &configKeyStickRight},
+    {.name = "puppycam_sensitivity_x", .type = CONFIG_TYPE_UINT, .uintValue = &puppycam_sensitivityX},
+    {.name = "puppycam_sensitivity_y", .type = CONFIG_TYPE_UINT, .uintValue = &puppycam_sensitivityY},
+    {.name = "puppycam_invert_x", .type = CONFIG_TYPE_UINT, .uintValue = &puppycam_invertX},
+    {.name = "puppycam_invert_y", .type = CONFIG_TYPE_UINT, .uintValue = &puppycam_invertY},
+    {.name = "puppycam_stopping_speed", .type = CONFIG_TYPE_UINT, .uintValue = &puppycam_degrade},
+    {.name = "puppycam_centre_aggression", .type = CONFIG_TYPE_UINT, .uintValue = &puppycam_aggression},
+    {.name = "puppycam_pan_amount", .type = CONFIG_TYPE_UINT, .uintValue = &puppycam_panlevel},
+
+
 };
 
 // Reads an entire line from a file (excluding the newline character) and returns an allocated string
diff --git a/src/pc/configfile.h b/src/pc/configfile.h
index ae9070b..514202d 100644
--- a/src/pc/configfile.h
+++ b/src/pc/configfile.h
@@ -16,6 +16,14 @@ extern unsigned int configKeyStickDown;
 extern unsigned int configKeyStickLeft;
 extern unsigned int configKeyStickRight;
 
+extern unsigned int puppycam_sensitivityX;
+extern unsigned int puppycam_sensitivityY;
+extern unsigned int puppycam_invertX;
+extern unsigned int puppycam_invertY;
+extern unsigned int puppycam_degrade;
+extern unsigned int puppycam_aggression;
+extern unsigned int puppycam_panlevel;
+
 void configfile_load(const char *filename);
 void configfile_save(const char *filename);
 
diff --git a/src/pc/controller/controller_sdl.c b/src/pc/controller/controller_sdl.c
index c3ab242..bb74a19 100644
--- a/src/pc/controller/controller_sdl.c
+++ b/src/pc/controller/controller_sdl.c
@@ -11,6 +11,8 @@
 
 #include "controller_api.h"
 
+s16 rightstick[2];
+
 #define DEADZONE 4960
 
 static bool init_ok;
@@ -92,6 +94,22 @@ static void controller_sdl_read(OSContPad *pad) {
         int stick_y = -lefty / 0x100;
         pad->stick_y = stick_y == 128 ? 127 : stick_y;
     }
+
+    uint32_t magnitude_sq2 = (uint32_t)(rightx * righty) + (uint32_t)(rightx * righty);
+            if (magnitude_sq2 > (uint32_t)(DEADZONE * DEADZONE)) {
+                rightstick[0] = rightx / 0x100;
+                rightstick[1] = righty / 0x100;
+            }
+            else
+            {
+                if (rightx < DEADZONE)
+                    rightstick[0] = 0;
+                if (righty < DEADZONE)
+                    rightstick[1] = 0;
+
+            }
+
+
 }
 
 struct ControllerAPI controller_sdl = {
diff --git a/src/pc/controller/controller_sdl.h b/src/pc/controller/controller_sdl.h
index 02aec8d..0fa2937 100644
--- a/src/pc/controller/controller_sdl.h
+++ b/src/pc/controller/controller_sdl.h
@@ -4,5 +4,6 @@
 #include "controller_api.h"
 
 extern struct ControllerAPI controller_sdl;
+extern s16 rightstick[2];
 
 #endif
diff --git a/src/pc/controller/controller_xinput.c b/src/pc/controller/controller_xinput.c
index bb44bc1..3d16161 100644
--- a/src/pc/controller/controller_xinput.c
+++ b/src/pc/controller/controller_xinput.c
@@ -9,6 +9,8 @@
 
 #define DEADZONE 4960
 
+s16 rightstick[2];
+
 static void xinput_init(void) {
 }
 
@@ -36,7 +38,21 @@ static void xinput_read(OSContPad *pad) {
                 pad->stick_x = gp->sThumbLX / 0x100;
                 pad->stick_y = gp->sThumbLY / 0x100;
             }
+            uint32_t magnitude_sq2 = (uint32_t)(gp->sThumbRX * gp->sThumbRX) + (uint32_t)(gp->sThumbRY * gp->sThumbRY);
+            if (magnitude_sq2 > (uint32_t)(DEADZONE * DEADZONE)) {
+                rightstick[0] = gp->sThumbRX / 0x100;
+                rightstick[1] = gp->sThumbRY / 0x100;
+            }
+            else
+            {
+                if (gp->sThumbRX < DEADZONE)
+                    rightstick[0] = 0;
+                if (gp->sThumbRY < DEADZONE)
+                    rightstick[1] = 0;
+
+            }
             break;
+
         }
     }
 }
diff --git a/src/pc/controller/controller_xinput.h b/src/pc/controller/controller_xinput.h
index be1e68c..0a7fa9a 100644
--- a/src/pc/controller/controller_xinput.h
+++ b/src/pc/controller/controller_xinput.h
@@ -6,6 +6,7 @@
 #include "controller_api.h"
 
 extern struct ControllerAPI controller_xinput;
+extern s16 rightstick[2];
 
 #endif
 
